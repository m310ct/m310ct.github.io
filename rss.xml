<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M310ct&#39;s blog</title>
  
  <subtitle>Welcome to M310ct&#39;s blog !!!</subtitle>
  <link href="https://m310ct.com/rss.xml" rel="self"/>
  
  <link href="https://m310ct.com/"/>
  <updated>2025-09-25T13:09:01.035Z</updated>
  <id>https://m310ct.com/</id>
  
  <author>
    <name>m310ct</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>七周七语言：Ruby</title>
    <link href="https://m310ct.com/2025/07/31/%E4%B8%83%E5%91%A8%E4%B8%83%E8%AF%AD%E8%A8%80Ruby/"/>
    <id>https://m310ct.com/2025/07/31/%E4%B8%83%E5%91%A8%E4%B8%83%E8%AF%AD%E8%A8%80Ruby/</id>
    <published>2025-07-30T16:00:00.000Z</published>
    <updated>2025-09-25T13:09:01.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-环境配置">1 环境配置</h2><h3 id="1-1-windows配置">1.1 windows配置</h3><ol><li><p>打开<a href="https://rubyinstaller.org/downloads/">RubyInstaller</a>，选择<code>rubyinstaller-devkit-3.4.4-2-x64.exe</code>，下载。</p></li><li><p>双击打开程序，选择Accept，点击Next。</p><p><img src="/images/ruby-1.png" alt=""></p></li><li><p>点击Browse安装到自定义位置，不想改直接Install。</p><p><img src="/images/ruby-2.png" alt=""></p></li><li><p>勾选<code>MSYS2</code>开发工具链，单机Next。</p><p><img src="/images/ruby-3.png" alt=""></p></li><li><p>下载完成后点击Finish</p><p><img src="/images/ruby-4.png" alt=""></p></li><li><p>会弹出一个命令行窗口，直接按Enter键，等待执行。</p><p><img src="/images/ruby-5.png" alt=""></p></li><li><p>到这一步，Enter键结束安装。<br><img src="/images/ruby-6.png" alt=""></p></li><li><p>打开cmd（win键+r，输入cmd），输入<code>ridk version</code>，看到类似输出则ridk安装正确。<br><img src="/images/ruby-7.png" alt=""></p></li><li><p>cmd输入<code>irb</code>进入ruby交互式环境，到这里已经可以执行ruby代码了，推荐配合vscode编辑器使用。</p></li></ol><h3 id="1-2-MacOS环境配置">1.2 MacOS环境配置</h3><ol><li>打开终端，安装Homebrew：</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/bin/bash -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>安装<code>rbenv</code></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">brew install rbenv ruby-build<br></code></pre></td></tr></table></figure><ol start="3"><li>判断当前shell并修改配置文件</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span><br></code></pre></td></tr></table></figure><p>这行代码能判断你当前的shell环境。</p><ul><li>Zsh：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;eval &quot;$(rbenv init - zsh)&quot;&#x27;</span> &gt;&gt; ~/.zshrc<br><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><ul><li>Bash：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;eval &quot;$(rbenv init - bash)&quot;&#x27;</span> &gt;&gt; ~/.bash_profile<br><span class="hljs-built_in">source</span> ~/.bash_profile<br></code></pre></td></tr></table></figure><ol start="4"><li>安装ruby</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rbenv install 3.2.2<br>rbenv global 3.2.2<br></code></pre></td></tr></table></figure><p>验证版本是否正确：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ruby -v<br></code></pre></td></tr></table></figure><p>你应该看到 <code>ruby 3.2.2</code> 之类的输出。</p><ol start="5"><li>安装Bundler（Ruby 包管理工具）</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gem install bundler<br></code></pre></td></tr></table></figure><ol start="6"><li>安装irb</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gem install pry<br></code></pre></td></tr></table></figure><p>终端输入<code>irb</code>进入交互环境。</p><div class="admonition warning"><p class="admonition-title">warning</p><ul><li>不建议直接使用系统自带的 Ruby（容易与 macOS 系统冲突）。</li><li>推荐使用 <code>rbenv</code> 来管理 Ruby 版本，便于升级和隔离项目环境。</li><li>安装 Ruby 时若遇到 readline 错误，可执行：<code>brew install openssl readline</code>。</li></ul></div><h3 id="1-3-执行代码">1.3 执行代码</h3><p>ruby代码分为两种执行方式，<strong>irb执行</strong>和<strong>文件执行</strong>。<br>简单的命令使用irb，而复杂的代码建议写入一个文件，通过ruby+文件名执行，比如：<code>ruby hello.rb</code>。<br>如果vscode推荐安装Run code插件快速运行。</p><h2 id="2-第一天：对象与流程控制">2.第一天：对象与流程控制</h2><div class="admonition abstract"><p class="admonition-title">abstract</p><p>本章节通过Ruby的对象系统、判断语句和循环结构，初步感受ruby的编程方式。</p></div><h3 id="2-1-起步">2.1 起步</h3><p>输出是学习一门编程语言最基础的一步。<br>打开irb，输入以下命令：</p><figure class="highlight rb"><table><tr><td class="code"><pre><code class="hljs rb">irb(main)<span class="hljs-symbol">:</span><span class="hljs-number">001</span>&gt; puts <span class="hljs-string">&quot;Hello,world&quot;</span><br><span class="hljs-title class_">Hello</span>,world<br>=&gt; nil<br>irb(main)<span class="hljs-symbol">:</span><span class="hljs-number">002</span>&gt; lang = <span class="hljs-string">&#x27;ruby&#x27;</span><br>=&gt; <span class="hljs-string">&quot;ruby&quot;</span><br>irb(main)<span class="hljs-symbol">:</span><span class="hljs-number">003</span>&gt; puts <span class="hljs-string">&quot;Hello <span class="hljs-subst">#&#123;lang&#125;</span>&quot;</span> <span class="hljs-comment">#这是模板字符串的用法</span><br><span class="hljs-title class_">Hello</span> ruby<br>=&gt; nil<br></code></pre></td></tr></table></figure><p>这三条代码中，传达了很多 Ruby 的核心特性：</p><ul><li>puts 是ruby的输出函数。</li><li>字符串用单引号 <code>''</code> 或双引号 <code>&quot;&quot;</code> 包裹。</li><li>变量 <strong>无需声明类型</strong>，可以直接赋值。</li><li>模板字符串使用 <code>#&#123;变量&#125;</code> 的格式，仅在双引号内有效。</li><li>Ruby的每条语句都有返回值。</li><li><code>nil</code> 代表空值。</li></ul><h3 id="2-2-编程模型">2.2 编程模型</h3><p>Ruby是一门纯面向对象的语言，在ruby中，一切皆对象。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):001:0&gt;</span> <span class="hljs-number">5</span>.<span class="hljs-keyword">class</span><br>=&gt; <span class="hljs-title class_">Integer</span><br><span class="hljs-meta prompt_">irb(main):002:0&gt;</span> <span class="hljs-number">5</span>.methods<br>=&gt;<br>[<span class="hljs-symbol">:remainder</span>,<br> <span class="hljs-symbol">:abs</span>,<br> <span class="hljs-symbol">:magnitude</span>,<br> <span class="hljs-symbol">:zero?</span>,<br> <span class="hljs-symbol">:floor</span>,<br> <span class="hljs-comment"># skip</span><br> <span class="hljs-symbol">:__id__</span>]<br></code></pre></td></tr></table></figure><p>在这个例子中，<br>一个对象具有个最基本的方法：</p><ul><li>obj.class：获取对象所属的类。比如 <code>5.class</code> 表示整数 <code>5</code> 的类为 <code>Integer</code>。</li><li>obj.methods：获取对象所有的方法，以列表返回。</li></ul><p>!!! tips “过时的内容”<br>原书中 <code>4.class</code> 返回 <code>Fixnum</code>，但从 Ruby 2.4 起，<code>Fixnum</code> 和 <code>Bignum</code> 已被统一为 <code>Integer</code>。<br>!!!</p><h3 id="2-3-判断与循环">2.3 判断与循环</h3><h4 id="布尔值">布尔值</h4><p>在 Ruby 中，每条语句都有返回值，所有返回值都可以归类为“真值”或“假值”。<br>只有 nil 和 false 被视为 假值，其他所有值，包括 0 和空字符串，都被视为 真值。需要注意的是，虽然 0 和其他非 false 或 nil 的值都被视为“真”，但它们并不等同于布尔值 true。<br>例如，0 == true 会返回 false，因为 0 和 true 是不同的值。</p><p>!!! tips “注意!”<br>在一些其他语言中，比如 <code>python</code>、<code>C/C++</code>中，<code>0</code> 也是 <code>false</code>。而在Ruby中，<code>0</code> 是 <code>true</code>。</p><h4 id="判断语句">判断语句</h4><ul><li>块形式：</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">if</span> condition<br>  statment<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li>单行形式：</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">statement <span class="hljs-keyword">if</span> condition <br></code></pre></td></tr></table></figure><h4 id="逻辑运算符">逻辑运算符</h4><ul><li><p>and：两个条件都为true，返回true</p></li><li><p>or：两个之中一个为true，返回true</p></li><li><p>逻辑短路：当表达式值已经明确求出就不会执行后面的表达式代码。<br>::: tip “逻辑短路例子”</p>  <figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span><br>  puts <span class="hljs-string">&quot;调用了a&quot;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span><br>  puts <span class="hljs-string">&quot;调用了b&quot;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><span class="hljs-keyword">end</span><br><br>puts <span class="hljs-string">&quot;---&amp;&amp;短路---&quot;</span><br>a &amp;&amp; b   <span class="hljs-comment"># 两个都执行，因为a是true，结果要看b</span><br><br>puts <span class="hljs-string">&quot;---||短路---&quot;</span><br>a |<span class="hljs-params"></span>| b   <span class="hljs-comment"># 只执行a，因为a是true，已经能决定结果，不再执行b</span><br></code></pre></td></tr></table></figure><p>输出：</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">---&amp;&amp;短路---<br>调用了a<br>调用了b<br>---||短路---<br>调用了a<br></code></pre></td></tr></table></figure></li></ul><div class="admonition tip"><p class="admonition-title">“逻辑运算符：&amp;&amp; / || 与 &amp; / | 的区别”</p><ul><li><p><code>&amp;&amp;</code> 和 <code>||</code> 是 <strong>逻辑运算符</strong>，具有<strong>短路行为</strong>：如果前一个条件已经可以决定结果，就不会再执行后一个条件。<br>例如：<code>false &amp;&amp; do_something()</code> 中，<code>do_something()</code> 不会被调用。</p></li><li><p><code>&amp;</code> 和 <code>|</code> 是 <strong>按位运算符</strong>，<strong>不具备短路特性</strong>，即使前面的条件已决定结果，也会继续执行后面的表达式。<br>同时，<code>&amp;</code> 和 <code>|</code> <strong>可以被重载</strong>，常用于集合操作、自定义对象的运算符重载等场景。</p></li></ul></div><div class="admonition tip"><p class="admonition-title">“重载”</p><p>所谓“重载”，就是<strong>重定义操作符对应的方法</strong>。比如下面这个例子：</p>  <figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">&amp;</span>(<span class="hljs-params">other</span>)<br>        puts <span class="hljs-string">&quot;执行自定义的 &amp; 运算&quot;</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    a = <span class="hljs-title class_">MyObject</span>.new<br>    b = <span class="hljs-title class_">MyObject</span>.new<br>    a &amp; b   <span class="hljs-comment"># 输出：执行自定义的 &amp; 运算</span><br></code></pre></td></tr></table></figure><p>本质上，&amp;、+、== 等都是方法名，调用 a &amp; b 等价于 a.&amp;(b)。这正是ruby语法糖的设计哲学之一。</p></div><h4 id="unless">unless</h4><p><code>unless</code> 是ruby中特有的条件关键字。</p><div class="admonition example"><p class="admonition-title">“书12页例”</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):001:0&gt;</span> x = <span class="hljs-number">4</span><br>=&gt; <span class="hljs-number">4</span><br><span class="hljs-meta prompt_">irb(main):002:0&gt;</span> puts <span class="hljs-string">&quot;This appears to be false&quot;</span> <span class="hljs-keyword">unless</span> x == <span class="hljs-number">4</span><br>=&gt; nil<br>irb(main)<span class="hljs-symbol">:</span><span class="hljs-number">003</span><span class="hljs-symbol">:</span><span class="hljs-number">0</span>&gt;<br></code></pre></td></tr></table></figure><p>在这个例子中，如果x不等于4才会输出内容。</p></div><p>通俗的解释，<code>unless</code> 可以理解为 <code>if not</code>。带入语言的语境就是 “除非x等于4，否则就打印”</p><h4 id="until循环">until循环</h4><p>和之前的 <code>unless</code> 一样，通过单词的语义去理解until循环是最方便的。unless是直到的意思，放在语境中就是“一只做某事直到条件达成”</p><div class="admonition example"><p class="admonition-title">“书13页例”</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs ruby2879">irb(main):001:0&gt; x = 10<br>=&gt; 10<br>irb(main):002:0&gt; x = x - 1 until x == 1<br>=&gt; nil<br>irb(main):003:0&gt; x<br>=&gt; 1<br></code></pre></td></tr></table></figure><p>在这个例子中，虽没有显示，但是发生里9次循环，x-=1后判断x是否等于1，如果没有则继续，直到x=1。</p></div><h4 id="times循环">times循环</h4><p><code>Integer</code> 的实例有 <code>times方法</code>，即循环多少次。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):001:0&gt;</span> <span class="hljs-number">3</span>.times &#123;puts <span class="hljs-string">&quot;a&quot;</span>&#125;<br>a<br>a<br>a<br>=&gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>times循环通常配合块使用。</p><h3 id="2-4-鸭子类型">2.4 鸭子类型</h3><p>鸭子类型并不是特定的语法，而是一种编程思想。国外有句谚语：</p><blockquote><p>“If it walks like a duck and it quacks like a duck, then it probably is a duck.”</p></blockquote><blockquote><p>如果它走起来像鸭子，叫起来也像鸭子，那它八成就是只鸭子。</p></blockquote><p>在 Ruby 中，对象的“类型”并不是最重要的，是否拥有某些行为（方法）才是关键。换句话说，只要一个对象实现了某个方法，它就可以“扮演”需要这个方法的角色。</p><p>这种做法被称为<strong>行为驱动</strong>，是 Ruby 这类动态语言的一大特色。</p><p>简而言之，不同的类实实现同一套类的名字就是鸭子方法的本质。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span><br>    puts <span class="hljs-string">&quot;Woof!&quot;</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span><br>    puts <span class="hljs-string">&quot;Quack!&quot;</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_it_speak</span>(<span class="hljs-params">animal</span>)<br>  animal.speak<br><span class="hljs-keyword">end</span><br><br>make_it_speak(<span class="hljs-title class_">Dog</span>.new)   <span class="hljs-comment"># =&gt; Woof!</span><br>make_it_speak(<span class="hljs-title class_">Duck</span>.new)  <span class="hljs-comment"># =&gt; Quack!</span><br></code></pre></td></tr></table></figure><p>这里的 <code>make_it_speak</code> 函数不在乎参数是 <code>Dog</code> 还是 <code>Duck</code>，只关心你有没有 <code>speak</code> 方法。</p><h2 id="3-第二天：函数，数组与代码块">3.第二天：函数，数组与代码块</h2><div class="admonition abstract"><p class="admonition-title">abstract</p><pre><code>在第二天的学习中，我们将深入 Ruby 的三大基础组成：函数（方法）、数组（Array） 与 代码块（Block）。它们共同构成了 Ruby 编程的核心操作与风格。</code></pre></div><h3 id="3-1-函数">3.1 函数</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">funcname</span>(<span class="hljs-params">arg</span>)<br>  statement<br><span class="hljs-keyword">end</span><br>funcname(arg) <span class="hljs-comment"># 调用函数</span><br></code></pre></td></tr></table></figure><p>Ruby中函数的定义非常的方便：</p><ul><li>使用 def 关键字定义方法，以 end 结束。</li><li>方法名后可以跟参数列表，括号可省略（特别是无参时）。</li><li>不需要显示使用<code>return</code>关键字，函数会返回最后一条代码的值。</li><li>调用函数时如果没有参数不需要括号。</li><li>有参数也可与直接写在后面而不用括号。只限于一个参数。</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>)<br>  <span class="hljs-string">&quot;Hello, <span class="hljs-subst">#&#123;name&#125;</span>!&quot;</span><br><span class="hljs-keyword">end</span><br><br>puts greet(<span class="hljs-string">&quot;Ruby&quot;</span>)    <span class="hljs-comment"># 输出：Hello, Ruby!</span><br>puts greet <span class="hljs-string">&quot;World&quot;</span>     <span class="hljs-comment"># 小括号也可以省略</span><br></code></pre></td></tr></table></figure><blockquote><p>Ruby 语法强调简洁、可读和自然语言风格，这种灵活的函数调用形式正体现了 Ruby 的设计哲学。</p></blockquote><h3 id="3-2-数组与切片">3.2 数组与切片</h3><p>数组是一种有序集合，可以存储多个对象，类型可以混合。它类似于 Python 中的 <code>list</code>。</p><ul><li>数组中可以存储不同类型的元素。</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):001:0&gt;</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;two&#x27;</span>,<span class="hljs-number">3.0</span>]<br>=&gt; [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-number">3.0</span>]<br></code></pre></td></tr></table></figure><ul><li><code>数组名[index]</code> 访问元素，负数代表从后往前。</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):002:0&gt;</span> arr[<span class="hljs-number">0</span>]<br>=&gt; <span class="hljs-number">1</span><br><span class="hljs-meta prompt_">irb(main):003:0&gt;</span> arr[-<span class="hljs-number">1</span>]<br>=&gt; <span class="hljs-number">3.0</span><br></code></pre></td></tr></table></figure><ul><li><code>数组名[index] = ''</code> 通过下表修改元素。</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):004:0&gt;</span> arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;one&#x27;</span><br>=&gt; <span class="hljs-string">&quot;one&quot;</span><br><span class="hljs-meta prompt_">irb(main):005:0&gt;</span> arr<br>=&gt; [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-number">3.0</span>]<br></code></pre></td></tr></table></figure><ul><li><code>&lt;&lt;</code> 添加元素到末尾。</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):006:0&gt;</span> arr &lt;&lt; <span class="hljs-string">&#x27;four&#x27;</span><br>=&gt; [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-number">3.0</span>, <span class="hljs-string">&quot;four&quot;</span>]<br></code></pre></td></tr></table></figure><ul><li><code>数组名.push(元素)</code> 添加元素到末尾。</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):007:0&gt;</span> arr.push(<span class="hljs-number">5</span>)<br>=&gt; [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-number">3.0</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><ul><li><code>pop</code> 删除列表最后一个元素并返回这个元素。</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):008:0&gt;</span> arr.pop<br>=&gt; <span class="hljs-number">5</span><br><span class="hljs-meta prompt_">irb(main):009:0&gt;</span> arr<br>=&gt; [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-number">3.0</span>, <span class="hljs-string">&quot;four&quot;</span>]<br></code></pre></td></tr></table></figure><ul><li><code>数组名[start_inde,end_index]</code> 数组切片，不包含end_index。</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):010:0&gt;</span> arr[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]<br>=&gt; [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="3-3-散列表与符号">3.3 散列表与符号</h3><p>散列表中每个元素是键值对的形式，类似python中的<code>dict</code>。<br>如果键是字符，必须在前面添加冒号，叫做符号（Symble）。</p><div class="admonition tip"><p class="admonition-title">“为什么散列表使用符号作为键？”</p><pre><code>在 Ruby 中，使用符号（Symbol）作为散列表的键有几个主要原因：- 符号的定义就是一个固定内存地址的标识。- 符号在内存中只会存留一个副本，无论在程序中使用多少相同的符号多会指向同一个内存。- 符号内存占用非常小</code></pre></div><ul><li>散列表通过大括号包裹的形式定义，其中每项对应 <code>key=&gt;value</code></li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):001:0&gt;</span> user = &#123;<span class="hljs-symbol">:name=&gt;<span class="hljs-string">&quot;m310ct&quot;</span></span>,<span class="hljs-symbol">:age=&gt;</span><span class="hljs-number">17</span>&#125;<br>=&gt; &#123;<span class="hljs-symbol">:name=&gt;<span class="hljs-string">&quot;m310ct&quot;</span></span>, <span class="hljs-symbol">:age=&gt;</span><span class="hljs-number">17</span>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>散列表名[key]</code> 获取对应的value</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):002:0&gt;</span> puts <span class="hljs-string">&quot;User name is <span class="hljs-subst">#&#123;user[<span class="hljs-symbol">:name</span>]&#125;</span>&quot;</span><br><span class="hljs-title class_">User</span> name is m310ct<br>=&gt; nil<br></code></pre></td></tr></table></figure><ul><li><code>散列表[key] = value</code> 修改对应key的value</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):003:0&gt;</span> user[<span class="hljs-symbol">:name</span>] = <span class="hljs-string">&quot;m310ctaaa&quot;</span><br>=&gt; <span class="hljs-string">&quot;m310ctaaa&quot;</span><br><span class="hljs-meta prompt_">irb(main):004:0&gt;</span> user<br>=&gt; &#123;<span class="hljs-symbol">:name=&gt;<span class="hljs-string">&quot;m310ctaaa&quot;</span></span>, <span class="hljs-symbol">:age=&gt;</span><span class="hljs-number">17</span>&#125;<br></code></pre></td></tr></table></figure><p>散列表还能过模拟命名参数。</p><div class="admonition example"><p class="admonition-title">“书20页例”</p><pre><code><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):001:1*</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">tell_the_truth</span>(<span class="hljs-params">options=&#123;&#125;</span>)<br><span class="hljs-meta prompt_">irb(main):002:2*</span>   <span class="hljs-keyword">if</span> options[<span class="hljs-symbol">:profession</span>] == <span class="hljs-symbol">:layer</span><br><span class="hljs-meta prompt_">irb(main):003:2*</span>     <span class="hljs-string">&#x27;it could be believed that this is almost</span><br><span class="hljs-string">certainly not false.&#x27;</span><br><span class="hljs-meta prompt_">irb(main):004:2*</span>   <span class="hljs-keyword">else</span><br><span class="hljs-meta prompt_">irb(main):005:2*</span>     <span class="hljs-literal">true</span><br><span class="hljs-meta prompt_">irb(main):006:1*</span>   <span class="hljs-keyword">end</span><br><span class="hljs-meta prompt_">irb(main):007:0&gt;</span> <span class="hljs-keyword">end</span><br>=&gt; <span class="hljs-symbol">:tell_the_truth</span><br><span class="hljs-meta prompt_">irb(main):008:0&gt;</span> tell_the_truth<br>=&gt; true<br><span class="hljs-meta prompt_">irb(main):009:0&gt;</span> tell_the_truth <span class="hljs-symbol">:profession</span> =&gt; <span class="hljs-symbol">:layer</span><br>=&gt; <span class="hljs-string">&quot;it could be believed that this is almost certainly not false.&quot;</span><br></code></pre></td></tr></table></figure></code></pre></div><p><code>options</code>是一个散列表，作为 <code>tell_the_truth</code> 函数的参数，来模拟命名参数。判断如果传入的散列表中，<code>:profession</code> 对应的是 <code>:layer</code> 就返回字符串，否则返回true。这段代码理解起来有几个难点：</p><ul><li><p>调用语句 <code>tell_the_truth :profession =&gt; :layer</code>。之前说过，如果函数只有一个参数可以不加括号，这句代码其实等价于 <code>tell_the_truth (&#123;:profession =&gt; :layer&#125;)</code></p></li><li><p>散列表通过 <code>options[:profession]</code> 来访问键 <code>:profession</code> 的值。这里用的是 <strong>符号作为键</strong>，符合 Ruby 的习惯用法（原因参考前文的 Symbol tip）。</p></li></ul><h3 id="3-4-代码块与yield">3.4 代码块与yield</h3><p>在times循环的例子中已经接触过代码块了。</p><ul><li>代码块可以理解为一段 <strong>没有名字的函数</strong>。</li><li>代码块有两种书写形式：<ul><li>当只有一行代码时用花括号 <code>&#123;&#125;</code> 的形式</li><li>多行代码用 <code>do...end</code>。</li></ul></li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-number">3</span>.times &#123; puts <span class="hljs-string">&quot;Hello&quot;</span> &#125;<br><br><span class="hljs-number">3</span>.times <span class="hljs-keyword">do</span><br>  puts <span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="块参数">块参数</h4><p>就和函数有参数一样，代码块也可以接受参数，称为 <strong>块参数</strong>。<br>参数块的形式为 <code>|变量名|</code> ，代码块参数的值由调用它的方法在每次执行时传入。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):001:0&gt;</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].each &#123; |<span class="hljs-params">i</span>| puts i &#125;<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br>=&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h4 id="yield">yield</h4><p><code>yield</code> 用于调用代码块。<br><code>yield(参数)</code> 用于传递块参数。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):001:1*</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_name</span><br><span class="hljs-meta prompt_">irb(main):002:1*</span>   <span class="hljs-keyword">yield</span>(<span class="hljs-string">&quot;m310ct&quot;</span>)<br><span class="hljs-meta prompt_">irb(main):003:0&gt;</span> <span class="hljs-keyword">end</span><br>=&gt; <span class="hljs-symbol">:print_name</span><br><span class="hljs-meta prompt_">irb(main):004:1*</span> print_name <span class="hljs-keyword">do</span> |<span class="hljs-params">name</span>|<br><span class="hljs-meta prompt_">irb(main):005:1*</span>   puts <span class="hljs-string">&quot;Your name is <span class="hljs-subst">#&#123;name&#125;</span>&quot;</span><br><span class="hljs-meta prompt_">irb(main):006:0&gt;</span> <span class="hljs-keyword">end</span><br><span class="hljs-title class_">Your</span> name is m310ct<br>=&gt; nil<br></code></pre></td></tr></table></figure><p>在这个例子中，调用 <code>print_name</code> 函数的时候传入一个打印名字的代码块。<code>print_name</code> 中yield就相当于调用这个代码块并且给它穿入参数。</p><h4 id="block">&amp;block</h4><div class="admonition example"><p class="admonition-title">“21页例”</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):001:1*</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_block</span>(<span class="hljs-params">&amp;block</span>)<br><span class="hljs-meta prompt_">irb(main):002:1*</span>   block.call<br><span class="hljs-meta prompt_">irb(main):003:0&gt;</span> <span class="hljs-keyword">end</span><br>=&gt; <span class="hljs-symbol">:call_block</span><br><span class="hljs-meta prompt_">irb(main):004:1*</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">pass_block</span>(<span class="hljs-params">&amp;block</span>)<br><span class="hljs-meta prompt_">irb(main):005:1*</span>   call_block(&amp;block)<br><span class="hljs-meta prompt_">irb(main):006:0&gt;</span> <span class="hljs-keyword">end</span><br>=&gt; <span class="hljs-symbol">:pass_block</span><br><span class="hljs-meta prompt_">irb(main):007:0&gt;</span> pass_block &#123;puts <span class="hljs-string">&#x27;Hello,block&#x27;</span>&#125;<br><span class="hljs-title class_">Hello</span>,block<br>=&gt; nil<br></code></pre></td></tr></table></figure></div><p>这是一个 <strong>代码块传递机制</strong> 的一个经典例子。</p><ol><li><p><code>call_block</code> 函数</p> <figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">call_block</span>(<span class="hljs-params">&amp;block</span>)<br>  block.call<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li><code>&amp;block</code> 这个方法接收一个代码块作为参数，并将传进来的代码块封装为一个 <code>Proc</code> 对象。</li><li><code>block.call</code> 执行这个代码块。</li></ul><div class="admonition tip"><p class="admonition-title">“为什么要把代码块转为 Proc 对象？”</p><pre><code> - 在 Ruby 中，代码块并不是一个对象。 - 代码块无法当作普通变量使用、传来传去、赋值等操作。 - 如果希望代码块能和普通对象一样使用，就需要用 `&amp;block` 接收，并且用 `.call` 调用。</code></pre></div></li><li><p><code>pass_block</code> 函数</p> <figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pass_block</span>(<span class="hljs-params">&amp;block</span>)<br>  call_block(&amp;block)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li><code>pass_block</code> 也接收一个 <code>block</code>（用 <code>&amp;block</code>）。</li><li>它把这个 <code>block</code> 传给另一个方法 <code>call_block</code>。</li><li>传递的时候也需要加 <code>&amp;</code>，否则就是普通对象，<code>call_block</code> 不会把它当成 <code>block</code> 处理。</li></ul></li><li><p>调用 <code>pass_block &#123; puts 'Hello, block' &#125;</code></p><div class="admonition tip"><p class="admonition-title">“&amp; 的本质”</p><pre><code> 总结一句话：你用 `&amp;` 修饰的参数，在传入 block 时变成 `Proc`，在传入 `Proc` 时又能变回 block，`&amp;` 就是 `block` 和 `Proc` 之间的桥梁。 举个例子： <figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">&amp;block</span>)<br>  inner(&amp;block)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span><br>  puts <span class="hljs-string">&quot;准备执行 block&quot;</span><br>  <span class="hljs-keyword">yield</span><br>  puts <span class="hljs-string">&quot;执行完毕&quot;</span><br><span class="hljs-keyword">end</span><br><br>outer &#123; puts <span class="hljs-string">&quot;我是 block&quot;</span> &#125;<br></code></pre></td></tr></table></figure> - 在 `outer(&amp;block)` 会把 `block` 转为 `Proc`。 - 在 `inner(&amp;block)` 会把 `Proc` 转为 `block`。 - 即使方法定义时没有写任何形式参数，只要内部用了 `yield`，并且调用时传入了 `block`，`yield` 就能执行这个 `block`。这也是为什么 `inner` 函数没有写形参却可以执行传入的 block 的原因。</code></pre></div></li></ol><h2 id="4-第三天：类、模块与元编程">4.第三天：类、模块与元编程</h2><h3 id="4-1-定义类">4.1 定义类</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>    <span class="hljs-built_in">attr_accessor</span> <span class="hljs-symbol">:name</span>, <span class="hljs-symbol">:age</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params">name, age</span>)<br>        <span class="hljs-variable">@name</span> = name<br>        <span class="hljs-variable">@age</span> = age<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">greet</span><br>        <span class="hljs-string">&quot;Hello, my name is <span class="hljs-subst">#&#123;<span class="hljs-variable">@name</span>&#125;</span> and I am <span class="hljs-subst">#&#123;<span class="hljs-variable">@age</span>&#125;</span> years old.&quot;</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>person = <span class="hljs-title class_">Person</span>.new(<span class="hljs-string">&quot;m310ct&quot;</span>, <span class="hljs-number">17</span>)<br>puts person.greet<br></code></pre></td></tr></table></figure><p>上面这个例子定义了一个 <code>Person</code> 类，实现了一个 <code>greet</code> 方法：</p><ul><li><code>attr_accessor :name, :age</code> 的作用是给 <code>name</code> 和 <code>age</code> 创建了 <code>getter</code> 和 <code>setter</code> 方法。<br>!!! tips “定义getter和setter方法”  <figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span> <span class="hljs-comment">#getter</span><br>    <span class="hljs-variable">@name</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">name=</span>(<span class="hljs-params">val</span>) <span class="hljs-comment">#setter</span><br>    <span class="hljs-variable">@name</span> = val<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>p = <span class="hljs-title class_">Person</span>.new<br>p.name = (<span class="hljs-string">&quot;m310ct&quot;</span>) <span class="hljs-comment"># 调用setter方法</span><br></code></pre></td></tr></table></figure><code>setter</code> 方法的形式比较怪异，调用方式也比较怪异。<br>区别于传统的直接传参数，Ruby 把赋值行为当作“方法调用”。<br>!!!</li><li><code>initialize</code> 方法会在类实例化时自动执行，一般在其中定义实例变量。</li></ul><h3 id="4-2-Mixin和模块">4.2 Mixin和模块</h3><p><strong>模块</strong> 是一种用于组织和复用代码的结构，无法实例化。</p><p><strong>Mixin</strong> 是一种代码复用机制，用于将模块中的方法“混入”类中，从而扩展类的功能，而无需继承。</p><div class="admonition example"><p class="admonition-title">“书25页例”</p><pre><code><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">module</span> <span class="hljs-title class_">ToFile</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">filename</span><br>    <span class="hljs-string">&quot;object_<span class="hljs-subst">#&#123;<span class="hljs-variable language_">self</span>.object_id&#125;</span>.txt&quot;</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">to_f</span><br>    <span class="hljs-title class_">File</span>.open(filename, <span class="hljs-string">&#x27;w&#x27;</span>) &#123;|<span class="hljs-params">f</span>| f.write(to_s) &#125;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>  <span class="hljs-keyword">include</span> <span class="hljs-title class_">ToFile</span><br>  <span class="hljs-built_in">attr_accessor</span> <span class="hljs-symbol">:name</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params">name</span>)<br>    <span class="hljs-variable">@name</span> = name<br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">to_s</span><br>    name <br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-title class_">Person</span>.new(<span class="hljs-string">&quot;Alice&quot;</span>).to_f<br></code></pre></td></tr></table></figure>这段代码的主要功能就是将传入的名字保存为一个txt文件。`module ToFile` 是一个创建并写入文件的模块，其中定义了两个方法：- filename方法：返回特定格式构建好的文件名- to_f 方法：创建并写入txt文件在 `class Person` 类中，通过 `inculde ToFile` 混入模块，就好像直接在 `Person` 类中写入了 `filename` 和 `to_f` 方法。这就是Mixin的体现，`ToFile` 封装了写入文件功能，之后可以复用。</code></pre></div><h3 id="4-3-枚举和集合">4.3 枚举和集合</h3><p><strong>枚举</strong> 和 <strong>比较</strong> 是ruby中至关重要的两个Mixin。</p><ul><li>枚举：要求类实现 <code>each</code> 方法</li><li>比较：要求类实现 <code>&lt;=&gt;</code> 太空船操作符。</li></ul><div class="admonition tip"><p class="admonition-title">“太空船操作符”</p><pre><code>`a &lt;=&gt; b`：快速判断大小的操作符。- a 大于 b：返回1- a 小于 b：返回-1- a 等于 b：返回0</code></pre></div><p><strong>集合</strong> 实现了很多便于使用的可枚举和课比较的方法。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):001:0&gt;</span> a = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>=&gt; [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>先创建一个数组，根据例子解释不同的方法：</p><ul><li><code>sort</code>：元素升序排列：</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):002:0&gt;</span> a.sort<br>=&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><ul><li><code>any?</code>：一个元素满足条件返回 <code>true</code>：</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):003:0&gt;</span> a.any? &#123;|<span class="hljs-params">i</span>| i &gt; <span class="hljs-number">3</span>&#125;<br>=&gt; true<br></code></pre></td></tr></table></figure><ul><li><code>all?</code>：全部元素满足条件返回 <code>true</code>：</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):004:0&gt;</span> a.all? &#123;|<span class="hljs-params">i</span>| i &gt; <span class="hljs-number">5</span>&#125;<br>=&gt; false<br></code></pre></td></tr></table></figure><ul><li><code>select</code>：列举所有满足条件的元素，以列表形式返回：</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):005:0&gt;</span> a.select &#123;|<span class="hljs-params">i</span>| i &gt; <span class="hljs-number">3</span>&#125;<br>=&gt; [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><ul><li><code>collect</code> 和 <code>map</code>：对每个元素执行操作：</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):007:0&gt;</span> a.collect &#123;|<span class="hljs-params">i</span>| i += <span class="hljs-number">1</span>&#125;<br>=&gt; [<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><ul><li><code>inject</code> 用于计算元素的和或积：</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">irb(main):008:0&gt;</span> a.inject &#123;|<span class="hljs-params">s,i</span>| s = s+i&#125;<br>=&gt; <span class="hljs-number">15</span><br><span class="hljs-meta prompt_">irb(main):010:0&gt;</span> a.inject &#123;|<span class="hljs-params">s,i</span>| s = s*i&#125;<br>=&gt; <span class="hljs-number">120</span><br><span class="hljs-meta prompt_">irb(main):013:0&gt;</span> a.inject(<span class="hljs-symbol">:+</span>)<br>=&gt; <span class="hljs-number">15</span><br><span class="hljs-meta prompt_">irb(main):014:0&gt;</span> a.inject(<span class="hljs-symbol">:*</span>)<br>=&gt; <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><h3 id="4-4-元编程">4.4 元编程</h3><p><strong>开放类</strong> 允许在任何时候重新打开已经存在的类并且修改其方法。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">to_chinese</span><br>    [<span class="hljs-string">&quot;零&quot;</span>, <span class="hljs-string">&quot;一&quot;</span>, <span class="hljs-string">&quot;二&quot;</span>, <span class="hljs-string">&quot;三&quot;</span>, <span class="hljs-string">&quot;四&quot;</span>, <span class="hljs-string">&quot;五&quot;</span>, <span class="hljs-string">&quot;六&quot;</span>, <span class="hljs-string">&quot;七&quot;</span>, <span class="hljs-string">&quot;八&quot;</span>, <span class="hljs-string">&quot;九&quot;</span>][<span class="hljs-variable language_">self</span>]<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>puts <span class="hljs-number">3</span>.to_chinese   <span class="hljs-comment"># 输出: 三</span><br>puts <span class="hljs-number">8</span>.to_chinese   <span class="hljs-comment"># 输出: 八</span><br></code></pre></td></tr></table></figure><p>这个例子就是给 <code>Integer</code> 类新添加一个方法，使数字能方便的转换为中文。</p><h4 id="method-missing">method_missing</h4><p>当ruby找不到某个方法的时候就会调用 <code>method_missing</code> 方法。可以人为重写这个方法来实现自定义功能。<br>通过 <code>self.method_missing</code>定义。有三个形参，分别是未找到的方法名、参数和代码块。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">self</span>.method_missing(method_name, *args, &amp;block)<br>        puts <span class="hljs-string">&quot;method_missing called for <span class="hljs-subst">#&#123;method_name&#125;</span>&quot;</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-title class_">Test</span>.qqq  <span class="hljs-comment">#调用一个不存在的方法会调用method_missing</span><br></code></pre></td></tr></table></figure><h4 id="元编程和常用方法">元编程和常用方法</h4><p>元编程就是<strong>程序写程序</strong>，简而言之即允许在运行时创建/删除/修改类、方法、变量，像魔术一样操作代码本身。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span><br>    [<span class="hljs-symbol">:name</span>,<span class="hljs-symbol">:age</span>].each <span class="hljs-keyword">do</span> |<span class="hljs-params">args</span>|<br>        <span class="hljs-built_in">define_method</span>(<span class="hljs-string">&quot;get_<span class="hljs-subst">#&#123;args&#125;</span>&quot;</span>) <span class="hljs-keyword">do</span><br>            instance_variable_get(<span class="hljs-string">&quot;@<span class="hljs-subst">#&#123;args&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-built_in">define_method</span>(<span class="hljs-string">&quot;set_<span class="hljs-subst">#&#123;args&#125;</span>&quot;</span>) <span class="hljs-keyword">do</span> |<span class="hljs-params">value</span>|<br>            instance_variable_set(<span class="hljs-string">&quot;@<span class="hljs-subst">#&#123;args&#125;</span>&quot;</span>,value)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>u = <span class="hljs-title class_">User</span>.new<br>u.set_age(<span class="hljs-number">10</span>)<br>puts u.get_age<br></code></pre></td></tr></table></figure><p>这段代码中，动态的创建了name和age两个实例变量并且依次创建了 <code>get</code> 和 <code>set</code> 方法。<br>常用元编程方法：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>define_method(name, &amp;block)</code></td><td>动态定义实例方法</td></tr><tr><td><code>instance_variable_get/set</code></td><td>读取或设置实例变量（通过字符串或 Symbol 访问）</td></tr><tr><td><code>send(:method_name, *args)</code></td><td>动态调用方法（包括私有方法）</td></tr><tr><td><code>method_missing(name, *args)</code></td><td>拦截未定义方法的调用，常用于实现动态行为或 DSL</td></tr><tr><td><code>define_singleton_method</code></td><td>为某个对象单独定义方法，不影响类中其他对象</td></tr><tr><td><code>class_eval</code> / <code>instance_eval</code></td><td>在类或对象上下文中动态执行代码，常用于修改行为</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">七周七语言Ruby部分</summary>
    
    
    
    <category term="编程语言" scheme="https://m310ct.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="七周七语言" scheme="https://m310ct.com/tags/%E4%B8%83%E5%91%A8%E4%B8%83%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Ruby" scheme="https://m310ct.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>重构VSCode：打造高效开发环境</title>
    <link href="https://m310ct.com/2025/07/20/%E9%87%8D%E6%9E%84VSCode%EF%BC%9A%E6%89%93%E9%80%A0%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://m310ct.com/2025/07/20/%E9%87%8D%E6%9E%84VSCode%EF%BC%9A%E6%89%93%E9%80%A0%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</id>
    <published>2025-07-19T16:00:00.000Z</published>
    <updated>2025-08-24T15:13:13.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言">0.前言</h2><p>VSCode是由微软开发的一款开源代码编辑器。具有跨平台、可拓展等优势。相对于Jetbrains家族的IDEs来说更为轻量，并且一个配置得当的VSCode可以进行全栈开发。</p><p>本文旨在记录VSCode配置的过程。</p><p>文章为了方便， 将直接给出 <code>settings.json</code> 的配置代码而不是在设置中进行手动点击。</p><p>所有插件都可以在插件商店中搜索，我也会给出每个插件的网址。</p><h3 id="打开settings-json-的方法">打开<code>settings.json</code> 的方法</h3><p><code>CTRL + ,</code> 打开设置界面。在右上角有一个“打开设置（json）”的图标，单机即可打开。</p><p>所有的配置文件按照 <code>json</code> 格式编写，全部写在一对大括号内，文中出现的代码不包括大括号。</p><h2 id="1-基础设置">1.基础设置</h2><h3 id="添加中文插件">添加中文插件</h3><p><code>CTRL + Shift + x</code> 打开插件，搜索chinese，选择中文简体安装，选择右下角弹框中的<code>Change Language and Restart</code> 或手动重启。</p><p>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans">Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code - Visual Studio Marketplace</a></p><h3 id="设置字体大小于样式">设置字体大小于样式</h3><p>由于我的显示器较大所以我设置的字体比较大，可以更具自己的习惯进行修改。</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.fontSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//设置字体大小</span><br><span class="hljs-attr">&quot;editor.fontFamily&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Monaspace Radon Frozen, monospace&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>Monaspace字体下载连接：<a href="https://monaspace.githubnext.com/">Monaspace</a></p><h3 id="设置光标样式">设置光标样式</h3><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.cursorBlinking&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;phase&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;editor.cursorSmoothCaretAnimation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;on&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//开启光标平滑动画</span><br><span class="hljs-attr">&quot;editor.cursorStyle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;line&quot;</span><span class="hljs-punctuation">,</span> <br></code></pre></td></tr></table></figure><h3 id="设置主题">设置主题</h3><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;workbench.colorTheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Noir Vira&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>NoirVira是一款黑色风格的主题，我十分推荐，因为是我自己开发的。</p><p>主题地址：<a href="https://marketplace.visualstudio.com/items?itemName=NoirVira.noir-vira">Noir Vira - Visual Studio Marketplace</a></p><h3 id="控制台设置">控制台设置</h3><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;terminal.integrated.fontSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//控制台字体</span><br><span class="hljs-attr">&quot;terminal.integrated.cursorBlinking&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//开启控制台光标闪烁</span><br></code></pre></td></tr></table></figure><h3 id="折行设置">折行设置</h3><p>当代码的某一行过长我们希望能够自动折叠这行代码。</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.wordWrap&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;on&quot;</span><span class="hljs-punctuation">,</span>              <span class="hljs-comment">// 打开自动换行</span><br><span class="hljs-attr">&quot;editor.wordWrapColumn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">80</span><span class="hljs-punctuation">,</span>          <span class="hljs-comment">// 控制在哪一列自动换行（可选）</span><br><span class="hljs-attr">&quot;editor.wrappingIndent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;same&quot;</span>       <span class="hljs-comment">// 换行后保持缩进</span><br></code></pre></td></tr></table></figure><h2 id="2-插件系统搭建">2.插件系统搭建</h2><h3 id="前端插件">前端插件</h3><ul><li><p><strong>Auto Rename Tag</strong>：修改 HTML 标签时自动重命名闭合标签</p><ul><li>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag">Auto Rename Tag - Visual Studio Marketplace</a></li></ul></li><li><p><strong>CSS Peek</strong>：可点击 CSS class 直接跳转定义</p><ul><li>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=pranaygp.vscode-css-peek">CSS Peek - Visual Studio Marketplace</a></li></ul></li><li><p><strong>Live Server</strong>：动态预览前端页面</p><ul><li>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer">Live Server - Visual Studio Marketplace</a></li></ul></li><li><p><strong>Console Ninja</strong>：在VSCode中显示console.log信息</p><ul><li>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=WallabyJs.console-ninja">Console Ninja - Visual Studio Marketplace</a></li></ul></li></ul><h3 id="代码增强插件">代码增强插件</h3><ul><li><p><strong>Prettier</strong>：格式化代码（快捷键<code>Shift + ALT + f</code>）</p><ul><li>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier - Code formatter - Visual Studio Marketplace</a></li></ul></li><li><p><strong>Code Spell Checker</strong>：自动检查拼写错误</p><ul><li>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker">Code Spell Checker - Visual Studio Marketplace</a></li></ul></li><li><p><strong>Markdown Preview Enhanced</strong>：markdown预览插件</p><ul><li>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced">Markdown Preview Enhanced - Visual Studio Marketplace</a></li></ul></li><li><p><strong>TODO Highlight</strong>：高亮TODO</p><ul><li>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight">TODO Highlight - Visual Studio Marketplace</a></li></ul></li><li><p><strong>Code Runner</strong>：在VSCode中直接运行代码</p><ul><li>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner">Code Runner - Visual Studio Marketplace</a></li></ul></li></ul><h3 id="编程语言插件">编程语言插件</h3><ul><li><p><strong>Python</strong>: <a href="https://marketplace.visualstudio.com/items?itemName=ms-python.python">Python - Visual Studio Marketplace</a></p></li><li><p><strong>JavaScript/TypeScript</strong>：内置支持。</p></li><li><p><strong>C/C++</strong>：</p><ul><li><p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack">C/C++ Extension Pack - Visual Studio Marketplace</a></p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C/C++ - Visual Studio Marketplace</a></p></li></ul></li><li><p><strong>Go</strong>: <a href="https://marketplace.visualstudio.com/items?itemName=golang.Go">Go - Visual Studio Marketplace</a></p></li><li><p><strong>PHP</strong>: <a href="https://marketplace.visualstudio.com/items?itemName=DEVSENSE.phptools-vscode">PHP - Visual Studio Marketplace</a></p></li></ul><h3 id="美化插件">美化插件</h3><ul><li><p><strong>indent-rainbow</strong>：然缩进具有颜色</p><ul><li>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow">indent-rainbow - Visual Studio Marketplace</a></li></ul></li><li><p><strong>Material Icon Theme</strong>：好看的文件图标</p><ul><li>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme">Material Icon Theme - Visual Studio Marketplace</a></li></ul></li><li><p><strong>Trailing Spaces</strong>：突出尾部空格</p><ul><li>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=shardulm94.trailing-spaces">Trailing Spaces - Visual Studio Marketplace</a></li></ul></li><li><p><strong>Path Intellisense</strong>：自动补全文件名</p><ul><li><p>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">Path Intellisense - Visual Studio Marketplace</a></p></li><li><p>替换JS和TS中的路径补全，在<code>settings.js</code>中写入：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;typescript.suggest.paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;javascript.suggest.paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="动画插件">动画插件</h3><p>安装<strong>VSCode Animations</strong>插件，根据右下角提示一直点击确认就可以获得一个丝滑的VSCode。</p><p><strong>注意：如果重启也不能让动画设置生效请可尝试重启电脑。</strong></p><p>如果想给鼠标也添加动画，在settings.js中添加：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;animations.CursorAnimation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br></code></pre></td></tr></table></figure><h2 id="3-远程开发于容器开发">3.远程开发于容器开发</h2><p>如果你在服务器（比如 Ubuntu Server）上开发，或者在 Docker 容器里跑项目，VSCode 的远程功能非常方便。</p><h3 id="远程-SSH-连接服务器">远程 SSH 连接服务器</h3><p>安装插件：<code>Remote - SSH</code><br>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh">Remote - SSH</a></p><p>按下 <code>F1</code> → 输入并选择 <code>Remote-SSH: Connect to Host...</code> → 添加主机。</p><h3 id="使用-Docker-容器开发">使用 Docker 容器开发</h3><p>安装插件：<code>Dev Containers</code><br>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers">Dev Containers</a></p><p>按下 <code>F1</code> → 输入并选择 <code>Dev Containers: Attach to Running Container...</code> → 选择容器即可进入。</p><h2 id="4-Git-工作流">4.Git 工作流</h2><p>VSCode 原生就支持 Git，只要你本地已经安装了 <code>git</code>，就可以直接使用。</p><h3 id="初始化-Git-仓库">初始化 Git 仓库</h3><p>点击左侧菜单的 <code>源代码管理（分支图标）</code> → 点击 <code>初始化仓库</code>。</p><p>或者直接打开终端输入：</p><p>bash</p><p>复制编辑</p><p><code>git init</code></p><h3 id="常用操作">常用操作</h3><ul><li><p><strong>提交代码</strong><br>修改完后点击左侧 Git 图标，填写提交信息，点击✅就能提交。</p></li><li><p><strong>查看修改</strong><br>文件左边会显示绿色/红色标记，点进去可以看到修改的内容。</p></li><li><p><strong>推送到远程仓库</strong></p></li></ul><p>先绑定远程仓库地址：</p><p>bash</p><p>复制编辑</p><p><code>git remote add origin git@github.com:你的用户名/你的项目.git</code></p><p>然后执行：</p><p>bash</p><p>复制编辑</p><p><code>git push -u origin main</code></p><h3 id="Git-插件推荐">Git 插件推荐</h3><ul><li><strong>GitLens</strong>：更详细的提交记录、作者信息查看<br>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens">GitLens - Visual Studio Marketplace</a></li></ul><h2 id="总结">总结</h2><p>VSCode 是一款高度可定制的编辑器，一个配置得当的 VSCode 足以覆盖大多数开发需求。</p><p>本文从<strong>基础设置</strong>、<strong>插件体系</strong>、<strong>远程开发</strong>、<strong>Git 集成</strong>等方面，梳理了完整的定制过程，重点突出<strong>颜值 ✚ 效率 ✚ 多语言适配</strong>。</p><p>你可以按需取用，也可以在此基础上打造属于你自己的开发环境。</p><blockquote><p>工具只是手段，真正提升效率的，是你对工具的理解与掌控。</p></blockquote>]]></content>
    
    
    <summary type="html">vscode深度定制，打造高效开发环境</summary>
    
    
    
    
    <category term="VSCode" scheme="https://m310ct.com/tags/VSCode/"/>
    
    <category term="开发工具" scheme="https://m310ct.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>轻量数据库的正确打开方式：Python x SQLite 教程</title>
    <link href="https://m310ct.com/2025/06/09/%E8%BD%BB%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%EF%BC%9APython%20%C3%97%20SQLite%20%E6%95%99%E7%A8%8B/"/>
    <id>https://m310ct.com/2025/06/09/%E8%BD%BB%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%EF%BC%9APython%20%C3%97%20SQLite%20%E6%95%99%E7%A8%8B/</id>
    <published>2025-06-08T16:00:00.000Z</published>
    <updated>2025-09-19T16:10:51.480Z</updated>
    
    <content type="html"><![CDATA[<p> </p><h2 id="0-为什么选择-Python-SQLite">0.为什么选择 Python + SQLite?</h2><p>在开发一些轻量级的项目时，相比起安装 MySQL、PostgreSQL 等大型数据库系统，SQLite 提供了一个“零配置、文件级、嵌入式”的解决方案 —— 只需要一个 <code>.db</code> 文件就能开始操作数据库。</p><p>而在Python内置的<code>sqlite3</code> 模块让操作sqlite变得非常简单，无需额外以来就能执行SQL语句，管理表结构。</p><p>接下来我们就一步一步通过实际代码来看看，如何用 Python 玩转 SQLite。</p><h2 id="1-连接数据库与创建数据库文件">1.连接数据库与创建数据库文件</h2><h3 id="文件数据库">文件数据库</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sqlite3<br>conn = sqlite3.connect(<span class="hljs-string">&quot;data.db&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><p><code>connect()</code>：本地创建或者打开数据库文件，参数为数据库文件路径</p></li><li><p><code>conn</code>：是<strong>连接对象</strong>，可以理解为数据库的会话窗口，通过conn可以：执行SQL，提交事务，回滚，关闭连接</p></li></ul><h2 id="内存数据库">内存数据库</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sqlite3<br>conn = sqlite3.connect(<span class="hljs-string">&quot;:memory:&quot;</span>)<br></code></pre></td></tr></table></figure><p>当<code>connect()</code>的参数为<code>:memory:</code>，sqlite将不会创建文件而是将文件存储在内存中，程序退出后数据消失，因为没有IO操作所以速度更快，一般用于程序测试时</p><h2 id="2-执行SQL命令">2.执行SQL命令</h2><h3 id="SQL-语句提交函数">SQL 语句提交函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">cursor = conn.cursor()<br>cursor.execute(<span class="hljs-string">&quot;INSERT INTO users (name) VALUES (?)&quot;</span>, (<span class="hljs-string">&quot;Bob&quot;</span>,))<br>conn.commit()<br></code></pre></td></tr></table></figure><ul><li><p><code>conn.cursor()</code>：返回一个<em>游标对象</em>，cursor扮演者一个执行SQL命令+获取查询结果的中间人角色</p></li><li><p><code>cursor.execute()</code>：提交SQL命令</p></li><li><p><code>conn.commit()</code>：<strong>提交事务</strong>，把你对数据库的所有改动<strong>永久写入数据库文件</strong></p></li></ul><h3 id="SQL预处理">SQL预处理</h3><h4 id="问号占位符">问号占位符</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">cursor.execute(<span class="hljs-string">&quot;SELECT * FROM users WHERE name = ?&quot;</span>, (<span class="hljs-string">&quot;Alice&quot;</span>,))<br></code></pre></td></tr></table></figure><ul><li>通过?的方式占位，参数必须为元组或者列表，具有自动转义和类型处理机制，有效防御SQLi</li></ul><h4 id="命名占位符">命名占位符</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">cursor.execute(<span class="hljs-string">&quot;SELECT * FROM users WHERE name = :name&quot;</span>, &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>命名占位符有更高的可读性</p></li><li><p>使用 <code>:参数名</code> 的方式</p></li><li><p>参数用字典传入</p></li><li><p>适合参数多、复杂时使用</p></li></ul><h3 id="非预期处理方式（风险写法❌）">非预期处理方式（风险写法❌）</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;Alice&quot;</span><br>cursor.execute(<span class="hljs-string">f&quot;SELECT * FROM users WHERE name = &#x27;<span class="hljs-subst">&#123;name&#125;</span>&#x27;&quot;</span>)<br></code></pre></td></tr></table></figure><p>字符串拼接的写法会导致SQL注入漏洞</p><h3 id="3-批量执行：executemany-的使用">3.批量执行：executemany 的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">data = [(<span class="hljs-string">&quot;Tom&quot;</span>,), (<span class="hljs-string">&quot;Jerry&quot;</span>,), (<span class="hljs-string">&quot;Spike&quot;</span>,)]<br>cursor.executemany(<span class="hljs-string">&quot;INSERT INTO users (name) VALUES (?)&quot;</span>, data)<br>conn.commit()<br></code></pre></td></tr></table></figure><ul><li><p><code>executemany()</code> 用于一次性插入多行数据</p></li><li><p>避免使用 <code>for</code> 循环+多次 <code>execute()</code>，更高效，更优雅</p></li></ul><h3 id="4-获取查询结果">4. 获取查询结果</h3><h4 id="返回结果的三种函数">返回结果的三种函数</h4><figure class="highlight py"><table><tr><td class="code"><pre><code class="hljs py">cursor.execute(<span class="hljs-string">&quot;SELECT * FROM users&quot;</span>)<br>rows = cursor.fetchall()<br>rows = cursor.fetchmany(n)<br>rows = cursor.fetchall()<br>conn.close()<br></code></pre></td></tr></table></figure><ul><li><p><code>fetchone()</code>：只获取一行</p></li><li><p><code>fetchmany(n)</code>：最多获取 n 行</p></li><li><p><code>fetchall()</code>：取所有结果，通常配合 for 使用</p></li></ul><h4 id="查询结果作为字典">查询结果作为字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">conn.row_factory = sqlite3.Row<br>cursor = conn.cursor()<br>cursor.execute(<span class="hljs-string">&quot;SELECT * FROM users&quot;</span>)<br>row = cursor.fetchone()<br><span class="hljs-built_in">print</span>(row[<span class="hljs-string">&quot;name&quot;</span>])  <span class="hljs-comment"># 像访问字典一样取字段值</span><br></code></pre></td></tr></table></figure><p>在默认情况下，SQLite 查询返回的是<strong>元组形式的结果</strong></p><p>虽然能用，但你必须记得字段的顺序（<code>row[1]</code> 是 <code>name</code>），<strong>代码可读性和健壮性都不高</strong>。</p><p>设置<code>conn.row_factory = sqlite3.Row</code> 之后再执行查询时，返回的每一行就变成了一个<strong>可以通过字段名访问的对象</strong></p><p><code>sqlite3.Row</code>实际上是一个特殊对象，支持<code>row[&quot;字段名&quot;]</code></p><h2 id="5-with自动管理连接">5.with自动管理连接</h2><p><code>sqlite3.connect()</code>返回的连接对象实现了上下文管理协议（即内部有<code>__enter__</code> 和 <code>__exit__</code> 方法），因此可以用 <code>with</code> 语法自动管理连接的生命周期。</p><p>传统写法<code>conn.close()</code>可能会导致数据未提交，文件锁未释放，内存泄漏等问题，而用<code>with</code>则可以自动调用<code>conn.commit()</code>和<code>conn.close()</code></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> sqlite3.connect(<span class="hljs-string">&quot;data.db&quot;</span>) <span class="hljs-keyword">as</span> conn:<br>    cursor = conn.cursor()<br>    cursor.execute(<span class="hljs-string">&quot;SELECT * FROM users&quot;</span>)<br>    rows = cursor.fetchall()<br></code></pre></td></tr></table></figure><h4 id="背后的原理">背后的原理</h4><p>Python 的 <code>with</code> 语句本质是调用对象的这两个方法：</p><ul><li><p><code>__enter__()</code>：进入时返回连接对象</p></li><li><p><code>__exit__()</code>：退出时自动：</p><ul><li><p>提交事务（如果没有出错）</p></li><li><p>或自动回滚（如果有异常）</p></li><li><p>然后关闭连接</p></li></ul></li></ul><p>SQLite 的连接对象内置了这个行为。</p><h2 id="6-总结">6.总结</h2><p>在本篇博客中，我们通过实际代码，介绍了如何用 Python 内置的 <code>sqlite3</code> 模块高效地操作 SQLite 数据库。你已经掌握了以下内容：</p><ul><li><p>使用 <code>sqlite3.connect()</code> 创建数据库连接，包括<strong>文件数据库</strong>与<strong>内存数据库</strong></p></li><li><p>使用 <code>conn.cursor()</code> 获取游标对象，执行 SQL 并获取查询结果</p></li><li><p>理解了 <strong>SQL 预处理语句</strong> 的作用与安全性（<code>?</code>、<code>:name</code>）</p></li><li><p>批量插入数据（<code>executemany</code>）的写法</p></li><li><p>多种结果读取方式（<code>fetchone()</code>、<code>fetchall()</code>、<code>row_factory</code>）</p></li><li><p>使用 <code>conn.commit()</code> 提交事务，确保数据持久化</p></li><li><p>利用 <code>with</code> 语法自动管理数据库连接，编写更安全的代码</p></li></ul><p>SQLite 是轻量、无依赖、嵌入式的理想选择，而 Python 则提供了简洁优雅的操作接口。两者结合，几乎可以应付所有小型项目、自动化脚本、离线工具、甚至 Web 后端的原型开发。</p>]]></content>
    
    
    <summary type="html">用 Python 演示如何使用 SQLite，从建库、建表到基本增删查改的完整流程</summary>
    
    
    
    <category term="编程语言" scheme="https://m310ct.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Python" scheme="https://m310ct.com/tags/Python/"/>
    
    <category term="SQLite" scheme="https://m310ct.com/tags/SQLite/"/>
    
    <category term="数据库" scheme="https://m310ct.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>hexploit使用指南</title>
    <link href="https://m310ct.com/2025/01/24/hexploit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://m310ct.com/2025/01/24/hexploit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2025-01-23T16:00:00.000Z</published>
    <updated>2025-09-19T16:09:38.804Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://m310ct.com/">Demo</a></p><h2 id="1-主题安装">1.主题安装</h2><p>可以通过git clone或下载压缩包的方式将项目下载到本地，在博客目录/themes下创建hexploit文件夹，将项目放进去（目录结构需要和github仓库里展示的一样，建议gitclone!）<br>打开博客目录下的config文件（在博客主目录和主题目录下都有config文件，注意不要混淆）:<br>修改theme: landscape：</p><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">hexploit</span><br></code></pre></td></tr></table></figure><h2 id="2-插件安装">2.插件安装</h2><h3 id="1-RSS插件">1.RSS插件</h3><p>在你的博客目录下输入命令（关于npm及博客安装等请自行搜索）</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install hexo-generator-feed --save<br></code></pre></td></tr></table></figure><p>打开博客目录下的config文件，在最后添加对rss的配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feed:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">rss</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">rss.xml</span><br></code></pre></td></tr></table></figure><h3 id="2-搜索插件">2.搜索插件</h3><p>在你的博客目录下输入命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install hexo-generator-search --save<br></code></pre></td></tr></table></figure><p>打开博客目录下的config文件，在最后添加搜索的配置：</p><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">search:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">search.json</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">all</span><br>  <span class="hljs-attr">format:</span> <span class="hljs-string">html</span><br>  <span class="hljs-attr">limit:</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><h2 id="3-添加对应页面">3.添加对应页面</h2><p>本主题一共支持三个页面，分别是categories,tags和about。</p><h3 id="1-新建页面">1.新建页面</h3><p>在博客目录输入命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hexo new page categories<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hexo new page tags<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure><h3 id="2-指定布局文件">2.指定布局文件</h3><p>这里以categories为例子，打开/source/categories/index.md，修改内容为：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">---<br>title: categories<br><span class="hljs-section">layout: categories</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>其他页面类似，将categories替换为tags和about</p><h3 id="3-修改主题配置文件">3.修改主题配置文件</h3><p>打开/themes/hexploit/_config.yml</p><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">menu:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Home</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">/</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Archives</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">/archives</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Categories</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">/categories</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Tags</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">/tags</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">About</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">/about</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">RSS</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">/rss.xml</span><br><span class="hljs-attr">sidebar:</span> <span class="hljs-comment">#侧边栏</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <br>  <span class="hljs-attr">widgets:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">search</span> <span class="hljs-comment">#搜索</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">notice</span> <span class="hljs-comment">#公告</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">categories</span> <span class="hljs-comment">#分类</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">tags</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">links</span> <span class="hljs-comment">#链接</span><br><br>  <span class="hljs-attr">numlimit:</span> <span class="hljs-comment"># 限制侧边栏显示的数量</span><br>    <span class="hljs-attr">categories:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">tags:</span> <span class="hljs-number">10</span><br><br>  <span class="hljs-attr">links:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">百度</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">https://www.baidu.com</span><br>  <span class="hljs-attr">notice:</span> <span class="hljs-comment"># 公告栏内容</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 设置为 true 启用，false 禁用</span><br>    <span class="hljs-attr">content:</span> <span class="hljs-string">&quot;博客正在进行优化，敬请期待更多内容！&quot;</span> <span class="hljs-comment"># 公告栏显示的内容</span><br><span class="hljs-attr">toc:</span> <span class="hljs-comment">#是否显示文章目录</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>侧边栏部分可以随意修改顺序或者将不使用的注释掉</p><h2 id="4-代码高亮">4.代码高亮</h2><p>修改博客配置文件：</p><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">highlight:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">wrap:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">hljs:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">prismjs:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>当前主题是atmo-one-dark，定义在highlight.css中，可自行修改</p>]]></content>
    
    
    <summary type="html">hexploit是一款hacker风格的hexo主题</summary>
    
    
    
    
    <category term="Hexo" scheme="https://m310ct.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
