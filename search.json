[{"title":"七周七语言：Ruby","url":"/2025/07/31/七周七语言Ruby/","content":"## 1 环境配置\n### 1.1 windows配置\n1. 打开[RubyInstaller](https://rubyinstaller.org/downloads/)，选择`rubyinstaller-devkit-3.4.4-2-x64.exe`，下载。\n2. 双击打开程序，选择Accept，点击Next。\n\n    ![](/images/ruby-1.png)\n\n3. 点击Browse安装到自定义位置，不想改直接Install。\n\n    ![](/images/ruby-2.png)\n\n4. 勾选`MSYS2`开发工具链，单机Next。\n\n    ![](/images/ruby-3.png)\n\n5. 下载完成后点击Finish\n\n    ![](/images/ruby-4.png)\n\n6. 会弹出一个命令行窗口，直接按Enter键，等待执行。\n\n    ![](/images/ruby-5.png)\n\n7. 到这一步，Enter键结束安装。\n    ![](/images/ruby-6.png)\n\n8. 打开cmd（win键+r，输入cmd），输入`ridk version`，看到类似输出则ridk安装正确。\n    ![](/images/ruby-7.png)\n\n9. cmd输入`irb`进入ruby交互式环境，到这里已经可以执行ruby代码了，推荐配合vscode编辑器使用。\n### 1.2 MacOS环境配置 \n1. 打开终端，安装Homebrew：\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n2. 安装`rbenv`\n```bash\nbrew install rbenv ruby-build\n```\n3. 判断当前shell并修改配置文件\n```bash\necho $SHELL\n```\n这行代码能判断你当前的shell环境。\n\n- Zsh：\n```bash\necho 'eval \"$(rbenv init - zsh)\"' >> ~/.zshrc\nsource ~/.zshrc\n```\n- Bash：\n```bash\necho 'eval \"$(rbenv init - bash)\"' >> ~/.bash_profile\nsource ~/.bash_profile\n```\n4. 安装ruby\n```bash\nrbenv install 3.2.2\nrbenv global 3.2.2\n```\n验证版本是否正确：\n```bash\nruby -v\n```\n你应该看到 `ruby 3.2.2` 之类的输出。\n\n5. 安装Bundler（Ruby 包管理工具）\n```bash\ngem install bundler\n```\n\n6. 安装irb\n```bash\ngem install pry\n```\n终端输入`irb`进入交互环境。\n!!! warning\n    - 不建议直接使用系统自带的 Ruby（容易与 macOS 系统冲突）。\n    - 推荐使用 `rbenv` 来管理 Ruby 版本，便于升级和隔离项目环境。\n    - 安装 Ruby 时若遇到 readline 错误，可执行：`brew install openssl readline`。\n### 1.3 执行代码\nruby代码分为两种执行方式，**irb执行**和**文件执行**。\n简单的命令使用irb，而复杂的代码建议写入一个文件，通过ruby+文件名执行，比如：`ruby hello.rb`。\n如果vscode推荐安装Run code插件快速运行。\n\n## 2.第一天：对象与流程控制\n!!! abstract\n    本章节通过Ruby的对象系统、判断语句和循环结构，初步感受ruby的编程方式。 \n### 2.1 起步\n输出是学习一门编程语言最基础的一步。\n打开irb，输入以下命令：\n```rb\nirb(main):001> puts \"Hello,world\"\nHello,world\n=> nil\nirb(main):002> lang = 'ruby'\n=> \"ruby\"\nirb(main):003> puts \"Hello #{lang}\" #这是模板字符串的用法\nHello ruby\n=> nil\n```\n这三条代码中，传达了很多 Ruby 的核心特性：\n\n- puts 是ruby的输出函数。\n- 字符串用单引号 `''` 或双引号 `\"\"` 包裹。\n- 变量 **无需声明类型**，可以直接赋值。\n- 模板字符串使用 `#{变量}` 的格式，仅在双引号内有效。\n- Ruby的每条语句都有返回值。\n- `nil` 代表空值。\n\n### 2.2 编程模型\nRuby是一门纯面向对象的语言，在ruby中，一切皆对象。\n```ruby\nirb(main):001:0> 5.class\n=> Integer\nirb(main):002:0> 5.methods\n=>\n[:remainder,\n :abs,\n :magnitude,\n :zero?,\n :floor,\n # skip\n :__id__]\n```\n在这个例子中，\n一个对象具有个最基本的方法：\n\n- obj.class：获取对象所属的类。比如 `5.class` 表示整数 `5` 的类为 `Integer`。\n- obj.methods：获取对象所有的方法，以列表返回。\n\n\n!!! tips \"\"\n    原书中 `4.class` 返回 `Fixnum`，但从 Ruby 2.4 起，`Fixnum` 和 `Bignum` 已被统一为 `Integer`。\n\n### 2.3 判断与循环\n#### 布尔值\n在 Ruby 中，每条语句都有返回值，所有返回值都可以归类为“真值”或“假值”。\n只有 nil 和 false 被视为 假值，其他所有值，包括 0 和空字符串，都被视为 真值。需要注意的是，虽然 0 和其他非 false 或 nil 的值都被视为“真”，但它们并不等同于布尔值 true。\n例如，0 == true 会返回 false，因为 0 和 true 是不同的值。\n\n!!! tips \"注意!\"\n    在一些其他语言中，比如 `python`、`C/C++`中，`0` 也是 `false`。而在Ruby中，`0` 是 `true`。\n#### 判断语句\n- 块形式：\n```ruby\nif condition\n  statment\nend\n```\n- 单行形式：\n```ruby\nstatement if condition \n```\n#### 逻辑运算符\n- and：两个条件都为true，返回true\n- or：两个之中一个为true，返回true\n- 逻辑短路：当表达式值已经明确求出就不会执行后面的表达式代码。\n??? tip \"逻辑短路例子\"\n\n    ```ruby\n    def a\n      puts \"调用了a\"\n      return true\n    end\n\n    def b\n      puts \"调用了b\"\n      return false\n    end\n\n    puts \"---&&短路---\"\n    a && b   # 两个都执行，因为a是true，结果要看b\n\n    puts \"---||短路---\"\n    a || b   # 只执行a，因为a是true，已经能决定结果，不再执行b\n    ```\n    输出：\n    ```\n    ---&&短路---\n    调用了a\n    调用了b\n    ---||短路---\n    调用了a\n    ```\n??? tip \"逻辑运算符：&& / || 与 & / | 的区别\"\n    - `&&` 和 `||` 是 **逻辑运算符**，具有**短路行为**：如果前一个条件已经可以决定结果，就不会再执行后一个条件。  \n      例如：`false && do_something()` 中，`do_something()` 不会被调用。\n    \n    - `&` 和 `|` 是 **按位运算符**，**不具备短路特性**，即使前面的条件已决定结果，也会继续执行后面的表达式。  \n      同时，`&` 和 `|` **可以被重载**，常用于集合操作、自定义对象的运算符重载等场景。\n??? tip \"重载\"\n    所谓“重载”，就是**重定义操作符对应的方法**。比如下面这个例子：\n    ```ruby\n    class MyObject\n        def &(other)\n            puts \"执行自定义的 & 运算\"\n        end\n        end\n\n        a = MyObject.new\n        b = MyObject.new\n        a & b   # 输出：执行自定义的 & 运算\n    ```\n    本质上，&、+、== 等都是方法名，调用 a & b 等价于 a.&(b)。这正是ruby语法糖的设计哲学之一。\n#### unless\n`unless` 是ruby中特有的条件关键字。\n!!! example \"书12页例\"\n    ```ruby\n    irb(main):001:0> x = 4\n    => 4\n    irb(main):002:0> puts \"This appears to be false\" unless x == 4\n    => nil\n    irb(main):003:0>\n    ```\n在这个例子中，如果x不等于4才会输出内容。\n\n通俗的解释，`unless` 可以理解为 `if not`。带入语言的语境就是 “除非x等于4，否则就打印”\n\n#### until循环\n和之前的 `unless` 一样，通过单词的语义去理解until循环是最方便的。unless是直到的意思，放在语境中就是“一只做某事直到条件达成”\n!!! example \"书13页例\"\n    ```ruby2879\n    irb(main):001:0> x = 10\n    => 10\n    irb(main):002:0> x = x - 1 until x == 1\n    => nil\n    irb(main):003:0> x\n    => 1\n    ```\n在这个例子中，虽没有显示，但是发生里9次循环，x-=1后判断x是否等于1，如果没有则继续，直到x=1。\n\n#### times循环\n`Integer` 的实例有 `times方法`，即循环多少次。\n```ruby\nirb(main):001:0> 3.times {puts \"a\"}\na\na\na\n=> 3\n```\ntimes循环通常配合块使用。\n\n### 2.4 鸭子类型\n鸭子类型并不是特定的语法，而是一种编程思想。国外有句谚语：\n>\"If it walks like a duck and it quacks like a duck, then it probably is a duck.\"\n\n>如果它走起来像鸭子，叫起来也像鸭子，那它八成就是只鸭子。\n\n在 Ruby 中，对象的“类型”并不是最重要的，是否拥有某些行为（方法）才是关键。换句话说，只要一个对象实现了某个方法，它就可以“扮演”需要这个方法的角色。\n\n这种做法被称为**行为驱动**，是 Ruby 这类动态语言的一大特色。\n\n简而言之，不同的类实实现同一套类的名字就是鸭子方法的本质。\n```ruby\nclass Dog\n  def speak\n    puts \"Woof!\"\n  end\nend\n\nclass Duck\n  def speak\n    puts \"Quack!\"\n  end\nend\n\ndef make_it_speak(animal)\n  animal.speak\nend\n\nmake_it_speak(Dog.new)   # => Woof!\nmake_it_speak(Duck.new)  # => Quack!\n```\n这里的 `make_it_speak` 函数不在乎参数是 `Dog` 还是 `Duck`，只关心你有没有 `speak` 方法。\n\n## 3.第二天：函数，数组与代码块\n!!! abstract \n    在第二天的学习中，我们将深入 Ruby 的三大基础组成：函数（方法）、数组（Array） 与 代码块（Block）。它们共同构成了 Ruby 编程的核心操作与风格。\n### 3.1 函数\n```ruby\ndef funcname(arg)\n  statement\nend\nfuncname(arg) # 调用函数\n```\nRuby中函数的定义非常的方便：\n\n- 使用 def 关键字定义方法，以 end 结束。\n- 方法名后可以跟参数列表，括号可省略（特别是无参时）。\n- 不需要显示使用`return`关键字，函数会返回最后一条代码的值。\n- 调用函数时如果没有参数不需要括号。\n- 有参数也可与直接写在后面而不用括号。只限于一个参数。\n\n```ruby\ndef greet(name)\n  \"Hello, #{name}!\"\nend\n\nputs greet(\"Ruby\")    # 输出：Hello, Ruby!\nputs greet \"World\"     # 小括号也可以省略\n```\n>Ruby 语法强调简洁、可读和自然语言风格，这种灵活的函数调用形式正体现了 Ruby 的设计哲学。\n\n### 3.2 数组与切片\n数组是一种有序集合，可以存储多个对象，类型可以混合。它类似于 Python 中的 `list`。\n\n- 数组中可以存储不同类型的元素。\n```ruby\nirb(main):001:0> arr = [1,'two',3.0]\n=> [1, \"two\", 3.0]\n```\n- `数组名[index]` 访问元素，负数代表从后往前。\n```ruby\nirb(main):002:0> arr[0]\n=> 1\nirb(main):003:0> arr[-1]\n=> 3.0\n```\n- `数组名[index] = ''` 通过下表修改元素。\n```ruby\nirb(main):004:0> arr[0] = 'one'\n=> \"one\"\nirb(main):005:0> arr\n=> [\"one\", \"two\", 3.0]\n```\n- `<<` 添加元素到末尾。\n```ruby\nirb(main):006:0> arr << 'four'\n=> [\"one\", \"two\", 3.0, \"four\"]\n```\n- `数组名.push(元素)` 添加元素到末尾。\n```ruby\nirb(main):007:0> arr.push(5)\n=> [\"one\", \"two\", 3.0, \"four\", 5]\n```\n- `pop` 删除列表最后一个元素并返回这个元素。\n```ruby\nirb(main):008:0> arr.pop\n=> 5\nirb(main):009:0> arr\n=> [\"one\", \"two\", 3.0, \"four\"]\n```\n- `数组名[start_inde,end_index]` 数组切片，不包含end_index。\n```ruby\nirb(main):010:0> arr[0,2]\n=> [\"one\", \"two\"]\n```\n\n### 3.3 散列表与符号\n散列表中每个元素是键值对的形式，类似python中的`dict`。\n如果键是字符，必须在前面添加冒号，叫做符号（Symble）。\n!!! tip \"为什么散列表使用符号作为键？\"\n    在 Ruby 中，使用符号（Symbol）作为散列表的键有几个主要原因：\n\n    - 符号的定义就是一个固定内存地址的标识。\n    - 符号在内存中只会存留一个副本，无论在程序中使用多少相同的符号多会指向同一个内存。\n    - 符号内存占用非常小\n\n\n- 散列表通过大括号包裹的形式定义，其中每项对应 `key=>value`\n```ruby\nirb(main):001:0> user = {:name=>\"m310ct\",:age=>17}\n=> {:name=>\"m310ct\", :age=>17}\n```\n- `散列表名[key]` 获取对应的value\n```ruby \nirb(main):002:0> puts \"User name is #{user[:name]}\"\nUser name is m310ct\n=> nil\n```\n- `散列表[key] = value` 修改对应key的value\n```ruby\nirb(main):003:0> user[:name] = \"m310ctaaa\"\n=> \"m310ctaaa\"\nirb(main):004:0> user\n=> {:name=>\"m310ctaaa\", :age=>17}\n```\n\n散列表还能过模拟命名参数。\n!!! example \"书20页例\"\n    ```ruby\n    irb(main):001:1* def tell_the_truth(options={})\n    irb(main):002:2*   if options[:profession] == :layer\n    irb(main):003:2*     'it could be believed that this is almost\n    certainly not false.'\n    irb(main):004:2*   else\n    irb(main):005:2*     true\n    irb(main):006:1*   end\n    irb(main):007:0> end\n    => :tell_the_truth\n    irb(main):008:0> tell_the_truth\n    => true\n    irb(main):009:0> tell_the_truth :profession => :layer\n    => \"it could be believed that this is almost certainly not false.\"\n    ```\n`options`是一个散列表，作为 `tell_the_truth` 函数的参数，来模拟命名参数。判断如果传入的散列表中，`:profession` 对应的是 `:layer` 就返回字符串，否则返回true。这段代码理解起来有几个难点：\n\n- 调用语句 `tell_the_truth :profession => :layer`。之前说过，如果函数只有一个参数可以不加括号，这句代码其实等价于 `tell_the_truth ({:profession => :layer})`\n\n- 散列表通过 `options[:profession]` 来访问键 `:profession` 的值。这里用的是 **符号作为键**，符合 Ruby 的习惯用法（原因参考前文的 Symbol tip）。\n\n### 3.4 代码块与yield\n在times循环的例子中已经接触过代码块了。\n\n- 代码块可以理解为一段 **没有名字的函数**。\n- 代码块有两种书写形式：\n    - 当只有一行代码时用花括号 `{}` 的形式\n    - 多行代码用 `do...end`。\n\n```ruby\n3.times { puts \"Hello\" }\n\n3.times do\n  puts \"Hello\"\nend\n```\n\n#### 块参数\n就和函数有参数一样，代码块也可以接受参数，称为 **块参数**。\n参数块的形式为 `|变量名|` ，代码块参数的值由调用它的方法在每次执行时传入。\n```ruby\nirb(main):001:0> [1, 2, 3].each { |i| puts i }\n1\n2\n3\n=> [1, 2, 3]\n```\n\n#### yield\n`yield` 用于调用代码块。\n`yield(参数)` 用于传递块参数。\n```ruby\nirb(main):001:1* def print_name\nirb(main):002:1*   yield(\"m310ct\")\nirb(main):003:0> end\n=> :print_name\nirb(main):004:1* print_name do |name|\nirb(main):005:1*   puts \"Your name is #{name}\"\nirb(main):006:0> end\nYour name is m310ct\n=> nil\n```\n在这个例子中，调用 `print_name` 函数的时候传入一个打印名字的代码块。`print_name` 中yield就相当于调用这个代码块并且给它穿入参数。\n\n#### &block\n!!! example \"21页例\"\n```ruby\nirb(main):001:1* def call_block(&block)\nirb(main):002:1*   block.call\nirb(main):003:0> end\n=> :call_block\nirb(main):004:1* def pass_block(&block)\nirb(main):005:1*   call_block(&block)\nirb(main):006:0> end\n=> :pass_block\nirb(main):007:0> pass_block {puts 'Hello,block'}\nHello,block\n=> nil\n```\n这是一个 **代码块传递机制** 的一个经典例子。\n\n1. `call_block` 函数\n\n    ```ruby\n    def call_block(&block)\n      block.call\n    end\n    ```\n\n    - `&block` 这个方法接收一个代码块作为参数，并将传进来的代码块封装为一个 `Proc` 对象。\n    - `block.call` 执行这个代码块。\n\n    !!! tip \"为什么要把代码块转为 Proc 对象？\"\n        - 在 Ruby 中，代码块并不是一个对象。\n        - 代码块无法当作普通变量使用、传来传去、赋值等操作。\n        - 如果希望代码块能和普通对象一样使用，就需要用 `&block` 接收，并且用 `.call` 调用。\n\n2. `pass_block` 函数\n\n    ```ruby\n    def pass_block(&block)\n      call_block(&block)\n    end\n    ```\n\n    - `pass_block` 也接收一个 `block`（用 `&block`）。\n    - 它把这个 `block` 传给另一个方法 `call_block`。\n    - 传递的时候也需要加 `&`，否则就是普通对象，`call_block` 不会把它当成 `block` 处理。\n\n3. 调用 `pass_block { puts 'Hello, block' }`\n\n    !!! tip \"& 的本质\"\n        总结一句话：你用 `&` 修饰的参数，在传入 block 时变成 `Proc`，在传入 `Proc` 时又能变回 block，`&` 就是 `block` 和 `Proc` 之间的桥梁。\n\n        举个例子：\n\n        ```ruby\n        def outer(&block)\n          inner(&block)\n        end\n\n        def inner\n          puts \"准备执行 block\"\n          yield\n          puts \"执行完毕\"\n        end\n\n        outer { puts \"我是 block\" }\n        ```\n\n        - 在 `outer(&block)` 会把 `block` 转为 `Proc`。\n        - 在 `inner(&block)` 会把 `Proc` 转为 `block`。\n        - 即使方法定义时没有写任何形式参数，只要内部用了 `yield`，并且调用时传入了 `block`，`yield` 就能执行这个 `block`。这也是为什么 `inner` 函数没有写形参却可以执行传入的 block 的原因。\n\n\n## 4.第三天：类、模块与元编程\n\n### 4.1 定义类\n```ruby\nclass Person\n    attr_accessor :name, :age\n    \n    def initialize(name, age)\n        @name = name\n        @age = age\n    end\n    \n    def greet\n        \"Hello, my name is #{@name} and I am #{@age} years old.\"\n    end\nend\n    \nperson = Person.new(\"m310ct\", 17)\nputs person.greet\n```\n上面这个例子定义了一个 `Person` 类，实现了一个 `greet` 方法：\n\n- `attr_accessor :name, :age` 的作用是给 `name` 和 `age` 创建了 `getter` 和 `setter` 方法。\n??? tips \"定义getter和setter方法\"\n    ```ruby\n    class Person\n      def name #getter\n        @name\n      end\n\n      def name=(val) #setter\n        @name = val\n      end\n    end\n\n    p = Person.new\n    p.name = (\"m310ct\") # 调用setter方法\n    ```\n    `setter` 方法的形式比较怪异，调用方式也比较怪异。\n    区别于传统的直接传参数，Ruby 把赋值行为当作“方法调用”。\n    \n- `initialize` 方法会在类实例化时自动执行，一般在其中定义实例变量。\n\n### 4.2 Mixin和模块\n**模块** 是一种用于组织和复用代码的结构，无法实例化。\n\n**Mixin** 是一种代码复用机制，用于将模块中的方法“混入”类中，从而扩展类的功能，而无需继承。\n\n!!! example \"书25页例\"\n    ```ruby\n    module ToFile\n      def filename\n        \"object_#{self.object_id}.txt\"\n      end\n\n      def to_f\n        File.open(filename, 'w') {|f| f.write(to_s) }\n      end\n    end\n\n    class Person\n      include ToFile\n      attr_accessor :name\n      def initialize(name)\n        @name = name\n      end\n      def to_s\n        name \n      end\n    end\n\n    Person.new(\"Alice\").to_f\n    ```\n    这段代码的主要功能就是将传入的名字保存为一个txt文件。\n    `module ToFile` 是一个创建并写入文件的模块，其中定义了两个方法：\n    \n    - filename方法：返回特定格式构建好的文件名\n    - to_f 方法：创建并写入txt文件\n\n    在 `class Person` 类中，通过 `inculde ToFile` 混入模块，就好像直接在 `Person` 类中写入了 `filename` 和 `to_f` 方法。\n\n    这就是Mixin的体现，`ToFile` 封装了写入文件功能，之后可以复用。\n\n### 4.3 枚举和集合\n**枚举** 和 **比较** 是ruby中至关重要的两个Mixin。\n\n- 枚举：要求类实现 `each` 方法\n- 比较：要求类实现 `<=>` 太空船操作符。\n\n??? tip \"太空船操作符\"\n    `a <=> b`：快速判断大小的操作符。\n\n    - a 大于 b：返回1\n    - a 小于 b：返回-1\n    - a 等于 b：返回0\n\n\n**集合** 实现了很多便于使用的可枚举和课比较的方法。\n\n```ruby \nirb(main):001:0> a = [5,4,3,2,1]\n=> [5,4,3,2,1]\n```\n先创建一个数组，根据例子解释不同的方法：\n\n- `sort`：元素升序排列：\n```ruby\nirb(main):002:0> a.sort\n=> [1, 2, 3, 4, 5]\n```\n\n- `any?`：一个元素满足条件返回 `true`：\n```ruby\nirb(main):003:0> a.any? {|i| i > 3}\n=> true\n```\n\n- `all?`：全部元素满足条件返回 `true`：\n```ruby\nirb(main):004:0> a.all? {|i| i > 5}\n=> false\n```\n\n- `select`：列举所有满足条件的元素，以列表形式返回：\n```ruby\nirb(main):005:0> a.select {|i| i > 3}\n=> [5, 4]\n```\n\n- `collect` 和 `map`：对每个元素执行操作：\n```ruby\nirb(main):007:0> a.collect {|i| i += 1}\n=> [6, 5, 4, 3, 2]\n```\n\n- `inject` 用于计算元素的和或积：\n```ruby\nirb(main):008:0> a.inject {|s,i| s = s+i}\n=> 15\nirb(main):010:0> a.inject {|s,i| s = s*i}\n=> 120\nirb(main):013:0> a.inject(:+)\n=> 15\nirb(main):014:0> a.inject(:*)\n=> 120\n```\n\n### 4.4 元编程\n**开放类** 允许在任何时候重新打开已经存在的类并且修改其方法。\n```ruby\nclass Integer\n  def to_chinese\n    [\"零\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\", \"七\", \"八\", \"九\"][self]\n  end\nend\n\nputs 3.to_chinese   # 输出: 三\nputs 8.to_chinese   # 输出: 八\n```\n这个例子就是给 `Integer` 类新添加一个方法，使数字能方便的转换为中文。\n\n#### method_missing\n当ruby找不到某个方法的时候就会调用 `method_missing` 方法。可以人为重写这个方法来实现自定义功能。\n通过 `self.method_missing`定义。有三个形参，分别是未找到的方法名、参数和代码块。\n```ruby\nclass Test\n    def self.method_missing(method_name, *args, &block)\n        puts \"method_missing called for #{method_name}\"\n    end\nend\n\nTest.qqq  #调用一个不存在的方法会调用method_missing\n```\n\n#### 元编程和常用方法\n元编程就是**程序写程序**，简而言之即允许在运行时创建/删除/修改类、方法、变量，像魔术一样操作代码本身。\n\n```ruby\nclass User\n    [:name,:age].each do |args|\n        define_method(\"get_#{args}\") do\n            instance_variable_get(\"@#{args}\")\n        end\n\n        define_method(\"set_#{args}\") do |value|\n            instance_variable_set(\"@#{args}\",value)\n        end\n    end\nend\n\nu = User.new\nu.set_age(10)\nputs u.get_age\n```\n这段代码中，动态的创建了name和age两个实例变量并且依次创建了 `get` 和 `set` 方法。\n常用元编程方法：\n\n| 方法名                            | 说明                          |\n| ------------------------------ | --------------------------- |\n| `define_method(name, &block)`  | 动态定义实例方法                    |\n| `instance_variable_get/set`    | 读取或设置实例变量（通过字符串或 Symbol 访问） |\n| `send(:method_name, *args)`    | 动态调用方法（包括私有方法）              |\n| `method_missing(name, *args)`  | 拦截未定义方法的调用，常用于实现动态行为或 DSL   |\n| `define_singleton_method`      | 为某个对象单独定义方法，不影响类中其他对象       |\n| `class_eval` / `instance_eval` | 在类或对象上下文中动态执行代码，常用于修改行为     |\n","tags":["七周七语言","Ruby"],"categories":["编程语言"]},{"title":"重构VSCode：打造高效开发环境","url":"/2025/07/20/重构VSCode：打造高效开发环境/","content":"\n## 0.前言\n\nVSCode是由微软开发的一款开源代码编辑器。具有跨平台、可拓展等优势。相对于Jetbrains家族的IDEs来说更为轻量，并且一个配置得当的VSCode可以进行全栈开发。\n\n本文旨在记录VSCode配置的过程。\n\n文章为了方便， 将直接给出 `settings.json` 的配置代码而不是在设置中进行手动点击。\n\n所有插件都可以在插件商店中搜索，我也会给出每个插件的网址。\n\n### 打开`settings.json` 的方法\n\n`CTRL + ,` 打开设置界面。在右上角有一个“打开设置（json）”的图标，单机即可打开。\n\n所有的配置文件按照 `json` 格式编写，全部写在一对大括号内，文中出现的代码不包括大括号。\n\n## 1.基础设置\n\n### 添加中文插件\n\n`CTRL + Shift + x` 打开插件，搜索chinese，选择中文简体安装，选择右下角弹框中的`Change Language and Restart` 或手动重启。\n\n插件地址：[Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans)\n\n### 设置字体大小于样式\n\n由于我的显示器较大所以我设置的字体比较大，可以更具自己的习惯进行修改。\n\n```json\n\"editor.fontSize\": 25, //设置字体大小\n\"editor.fontFamily\": \"Monaspace Radon Frozen, monospace\",\n```\n\nMonaspace字体下载连接：[Monaspace](https://monaspace.githubnext.com/)\n\n### 设置光标样式\n\n```json\n\"editor.cursorBlinking\": \"phase\",\n\"editor.cursorSmoothCaretAnimation\": \"on\",//开启光标平滑动画\n\"editor.cursorStyle\": \"line\", \n```\n\n### 设置主题\n\n```json\n\"workbench.colorTheme\": \"Noir Vira\",\n```\n\nNoirVira是一款黑色风格的主题，我十分推荐，因为是我自己开发的。\n\n主题地址：[Noir Vira - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=NoirVira.noir-vira)\n\n### 控制台设置\n\n```json\n\"terminal.integrated.fontSize\": 20, //控制台字体\n\"terminal.integrated.cursorBlinking\": true, //开启控制台光标闪烁\n```\n\n### 折行设置\n\n当代码的某一行过长我们希望能够自动折叠这行代码。\n\n```json\n\"editor.wordWrap\": \"on\",              // 打开自动换行\n\"editor.wordWrapColumn\": 80,          // 控制在哪一列自动换行（可选）\n\"editor.wrappingIndent\": \"same\"       // 换行后保持缩进\n```\n\n## 2.插件系统搭建\n\n### 前端插件\n\n- **Auto Rename Tag**：修改 HTML 标签时自动重命名闭合标签\n  \n  - 插件地址：[Auto Rename Tag - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag)\n- **CSS Peek**：可点击 CSS class 直接跳转定义\n  \n  - 插件地址：[CSS Peek - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=pranaygp.vscode-css-peek)\n- **Live Server**：动态预览前端页面\n  \n  - 插件地址：[Live Server - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer)\n- **Console Ninja**：在VSCode中显示console.log信息\n  \n  - 插件地址：[Console Ninja - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=WallabyJs.console-ninja)\n\n### 代码增强插件\n\n- **Prettier**：格式化代码（快捷键`Shift + ALT + f`）\n  \n  - 插件地址：[Prettier - Code formatter - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)\n- **Code Spell Checker**：自动检查拼写错误\n  \n  - 插件地址：[Code Spell Checker - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker)\n- **Markdown Preview Enhanced**：markdown预览插件\n  \n  - 插件地址：[Markdown Preview Enhanced - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced)\n- **TODO Highlight**：高亮TODO\n  \n  - 插件地址：[TODO Highlight - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight)\n- **Code Runner**：在VSCode中直接运行代码\n  \n  - 插件地址：[Code Runner - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner)\n\n### 编程语言插件\n\n- **Python**: [Python - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=ms-python.python)\n  \n- **JavaScript/TypeScript**：内置支持。\n  \n- **C/C++**：\n  \n  - [C/C++ Extension Pack - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack)\n    \n  - [C/C++ - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)\n    \n- **Go**: [Go - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=golang.Go)\n  \n- **PHP**: [PHP - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=DEVSENSE.phptools-vscode)\n  \n\n### 美化插件\n\n- **indent-rainbow**：然缩进具有颜色\n  \n  - 插件地址：[indent-rainbow - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow)\n- **Material Icon Theme**：好看的文件图标\n  \n  - 插件地址：[Material Icon Theme - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme)\n- **Trailing Spaces**：突出尾部空格\n  \n  - 插件地址：[Trailing Spaces - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=shardulm94.trailing-spaces)\n    \n- **Path Intellisense**：自动补全文件名\n  \n  - 插件地址：[Path Intellisense - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense)\n    \n  - 替换JS和TS中的路径补全，在`settings.js`中写入：\n    \n    ```json\n    \"typescript.suggest.paths\": false,\n    \"javascript.suggest.paths\": false,\n    ```\n    \n\n### 动画插件\n\n安装**VSCode Animations**插件，根据右下角提示一直点击确认就可以获得一个丝滑的VSCode。\n\n**注意：如果重启也不能让动画设置生效请可尝试重启电脑。**\n\n如果想给鼠标也添加动画，在settings.js中添加：\n\n```json\n\"animations.CursorAnimation\": true\n```\n\n## 3.远程开发于容器开发\n\n如果你在服务器（比如 Ubuntu Server）上开发，或者在 Docker 容器里跑项目，VSCode 的远程功能非常方便。\n\n### 远程 SSH 连接服务器\n\n安装插件：`Remote - SSH`  \n插件地址：[Remote - SSH](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh)\n\n按下 `F1` → 输入并选择 `Remote-SSH: Connect to Host...` → 添加主机。\n\n### 使用 Docker 容器开发\n\n安装插件：`Dev Containers`\n插件地址：[Dev Containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers)\n\n按下 `F1` → 输入并选择 `Dev Containers: Attach to Running Container...` → 选择容器即可进入。\n\n## 4.Git 工作流\n\nVSCode 原生就支持 Git，只要你本地已经安装了 `git`，就可以直接使用。\n\n### 初始化 Git 仓库\n\n点击左侧菜单的 `源代码管理（分支图标）` → 点击 `初始化仓库`。\n\n或者直接打开终端输入：\n\nbash\n\n复制编辑\n\n`git init`\n\n### 常用操作\n\n- **提交代码**  \n  修改完后点击左侧 Git 图标，填写提交信息，点击✅就能提交。\n  \n- **查看修改**  \n  文件左边会显示绿色/红色标记，点进去可以看到修改的内容。\n  \n- **推送到远程仓库**\n  \n\n先绑定远程仓库地址：\n\nbash\n\n复制编辑\n\n`git remote add origin git@github.com:你的用户名/你的项目.git`\n\n然后执行：\n\nbash\n\n复制编辑\n\n`git push -u origin main`\n\n### Git 插件推荐\n\n- **GitLens**：更详细的提交记录、作者信息查看  \n  插件地址：[GitLens - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens)\n\n## 总结\n\nVSCode 是一款高度可定制的编辑器，一个配置得当的 VSCode 足以覆盖大多数开发需求。\n\n本文从**基础设置**、**插件体系**、**远程开发**、**Git 集成**等方面，梳理了完整的定制过程，重点突出**颜值 ✚ 效率 ✚ 多语言适配**。\n\n你可以按需取用，也可以在此基础上打造属于你自己的开发环境。\n\n> 工具只是手段，真正提升效率的，是你对工具的理解与掌控。\n","tags":["VSCode","开发工具"]},{"title":"轻量数据库的正确打开方式：Python x SQLite 教程","url":"/2025/06/09/轻量数据库的正确打开方式：Python × SQLite 教程/","content":"\n&nbsp;\n\n## 0.为什么选择 Python + SQLite?\n\n在开发一些轻量级的项目时，相比起安装 MySQL、PostgreSQL 等大型数据库系统，SQLite 提供了一个“零配置、文件级、嵌入式”的解决方案 —— 只需要一个 `.db` 文件就能开始操作数据库。\n\n而在Python内置的`sqlite3` 模块让操作sqlite变得非常简单，无需额外以来就能执行SQL语句，管理表结构。\n\n接下来我们就一步一步通过实际代码来看看，如何用 Python 玩转 SQLite。\n\n## 1.连接数据库与创建数据库文件\n\n### 文件数据库\n\n```python\nimport sqlite3\nconn = sqlite3.connect(\"data.db\")\n```\n\n- `connect()`：本地创建或者打开数据库文件，参数为数据库文件路径\n\n- `conn`：是**连接对象**，可以理解为数据库的会话窗口，通过conn可以：执行SQL，提交事务，回滚，关闭连接\n\n## 内存数据库\n\n```python\nimport sqlite3\nconn = sqlite3.connect(\":memory:\")\n```\n\n当`connect()`的参数为`:memory:`，sqlite将不会创建文件而是将文件存储在内存中，程序退出后数据消失，因为没有IO操作所以速度更快，一般用于程序测试时\n\n## 2.执行SQL命令\n\n### SQL 语句提交函数\n\n```python\ncursor = conn.cursor()\ncursor.execute(\"INSERT INTO users (name) VALUES (?)\", (\"Bob\",))\nconn.commit()\n```\n\n- `conn.cursor()`：返回一个*游标对象*，cursor扮演者一个执行SQL命令+获取查询结果的中间人角色\n\n- `cursor.execute()`：提交SQL命令\n\n- `conn.commit()`：**提交事务**，把你对数据库的所有改动**永久写入数据库文件**\n\n### SQL预处理\n\n#### 问号占位符\n\n```python\ncursor.execute(\"SELECT * FROM users WHERE name = ?\", (\"Alice\",))\n```\n\n- 通过?的方式占位，参数必须为元组或者列表，具有自动转义和类型处理机制，有效防御SQLi\n\n#### 命名占位符\n\n```python\n cursor.execute(\"SELECT * FROM users WHERE name = :name\", {\"name\": \"Alice\"})\n```\n\n- 命名占位符有更高的可读性\n\n- 使用 `:参数名` 的方式\n\n- 参数用字典传入\n\n- 适合参数多、复杂时使用\n\n### 非预期处理方式（风险写法❌）\n\n```python\nname = \"Alice\"\ncursor.execute(f\"SELECT * FROM users WHERE name = '{name}'\")\n```\n\n字符串拼接的写法会导致SQL注入漏洞\n\n### 3.批量执行：executemany 的使用\n\n```python\ndata = [(\"Tom\",), (\"Jerry\",), (\"Spike\",)]\ncursor.executemany(\"INSERT INTO users (name) VALUES (?)\", data)\nconn.commit()\n```\n\n- `executemany()` 用于一次性插入多行数据\n\n- 避免使用 `for` 循环+多次 `execute()`，更高效，更优雅\n\n### 4. 获取查询结果\n\n#### 返回结果的三种函数\n\n```py\ncursor.execute(\"SELECT * FROM users\")\nrows = cursor.fetchall()\nrows = cursor.fetchmany(n)\nrows = cursor.fetchall()\nconn.close()\n```\n\n- `fetchone()`：只获取一行\n\n- `fetchmany(n)`：最多获取 n 行\n\n- `fetchall()`：取所有结果，通常配合 for 使用\n\n#### 查询结果作为字典\n\n```python\nconn.row_factory = sqlite3.Row\ncursor = conn.cursor()\ncursor.execute(\"SELECT * FROM users\")\nrow = cursor.fetchone()\nprint(row[\"name\"])  # 像访问字典一样取字段值\n```\n\n在默认情况下，SQLite 查询返回的是**元组形式的结果**\n\n虽然能用，但你必须记得字段的顺序（`row[1]` 是 `name`），**代码可读性和健壮性都不高**。\n\n设置`conn.row_factory = sqlite3.Row` 之后再执行查询时，返回的每一行就变成了一个**可以通过字段名访问的对象**\n\n`sqlite3.Row`实际上是一个特殊对象，支持`row[\"字段名\"]`\n\n## 5.with自动管理连接\n\n`sqlite3.connect()`返回的连接对象实现了上下文管理协议（即内部有`__enter__` 和 `__exit__` 方法），因此可以用 `with` 语法自动管理连接的生命周期。\n\n传统写法`conn.close()`可能会导致数据未提交，文件锁未释放，内存泄漏等问题，而用`with`则可以自动调用`conn.commit()`和`conn.close()`\n\n```python\nwith sqlite3.connect(\"data.db\") as conn:\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT * FROM users\")\n    rows = cursor.fetchall()\n```\n\n#### 背后的原理\n\nPython 的 `with` 语句本质是调用对象的这两个方法：\n\n- `__enter__()`：进入时返回连接对象\n\n- `__exit__()`：退出时自动：\n  \n  - 提交事务（如果没有出错）\n  \n  - 或自动回滚（如果有异常）\n  \n  - 然后关闭连接\n\nSQLite 的连接对象内置了这个行为。\n\n## 6.总结\n\n在本篇博客中，我们通过实际代码，介绍了如何用 Python 内置的 `sqlite3` 模块高效地操作 SQLite 数据库。你已经掌握了以下内容：\n\n- 使用 `sqlite3.connect()` 创建数据库连接，包括**文件数据库**与**内存数据库**\n\n- 使用 `conn.cursor()` 获取游标对象，执行 SQL 并获取查询结果\n\n- 理解了 **SQL 预处理语句** 的作用与安全性（`?`、`:name`）\n\n- 批量插入数据（`executemany`）的写法\n\n- 多种结果读取方式（`fetchone()`、`fetchall()`、`row_factory`）\n\n- 使用 `conn.commit()` 提交事务，确保数据持久化\n\n- 利用 `with` 语法自动管理数据库连接，编写更安全的代码\n\nSQLite 是轻量、无依赖、嵌入式的理想选择，而 Python 则提供了简洁优雅的操作接口。两者结合，几乎可以应付所有小型项目、自动化脚本、离线工具、甚至 Web 后端的原型开发。\n\n\n","tags":["Python","SQLite","数据库"],"categories":["编程语言"]},{"title":"hexploit使用指南","url":"/2025/01/24/hexploit使用指南/","content":"\n[Demo](https://m310ct.com/)\n\n## 1.主题安装\n\n可以通过git clone或下载压缩包的方式将项目下载到本地，在博客目录/themes下创建hexploit文件夹，将项目放进去（目录结构需要和github仓库里展示的一样，建议gitclone!）\n打开博客目录下的config文件（在博客主目录和主题目录下都有config文件，注意不要混淆）:\n修改theme: landscape：\n\n```yml\ntheme: hexploit\n```\n\n## 2.插件安装\n\n### 1.RSS插件\n\n在你的博客目录下输入命令（关于npm及博客安装等请自行搜索）\n\n```bash\nnpm install hexo-generator-feed --save\n```\n\n打开博客目录下的config文件，在最后添加对rss的配置\n\n```yml\nfeed:\n  type: rss\n  path: rss.xml\n```\n\n### 2.搜索插件\n\n在你的博客目录下输入命令：\n\n```bash\nnpm install hexo-generator-search --save\n```\n\n打开博客目录下的config文件，在最后添加搜索的配置：\n\n```yml\nsearch:\n  path: search.json\n  field: all\n  format: html\n  limit: 10000\n```\n\n## 3.添加对应页面\n\n本主题一共支持三个页面，分别是categories,tags和about。\n\n### 1.新建页面\n\n在博客目录输入命令：\n\n```bash\nhexo new page categories\n```\n\n```bash\nhexo new page tags\n```\n\n```bash\nhexo new page about\n```\n\n### 2.指定布局文件\n\n这里以categories为例子，打开/source/categories/index.md，修改内容为：\n\n```markdown\n---\ntitle: categories\nlayout: categories\n---\n```\n\n其他页面类似，将categories替换为tags和about\n\n### 3.修改主题配置文件\n\n打开/themes/hexploit/_config.yml\n\n```yml\nmenu:\n  - name: Home\n    url: /\n  - name: Archives\n    url: /archives\n  - name: Categories\n    url: /categories\n  - name: Tags\n    url: /tags\n  - name: About\n    url: /about\n  - name: RSS\n    url: /rss.xml\nsidebar: #侧边栏\n  enable: true \n  widgets:\n    - search #搜索\n    - notice #公告\n    - categories #分类\n    - tags #标签\n    - links #链接\n\n  numlimit: # 限制侧边栏显示的数量\n    categories: 5\n    tags: 10\n\n  links:\n    - name: 百度\n      url: https://www.baidu.com\n  notice: # 公告栏内容\n    enable: true # 设置为 true 启用，false 禁用\n    content: \"博客正在进行优化，敬请期待更多内容！\" # 公告栏显示的内容\ntoc: #是否显示文章目录\n  enable: true\n```\n\n侧边栏部分可以随意修改顺序或者将不使用的注释掉\n\n## 4.代码高亮\n\n修改博客配置文件：\n\n```yml\nhighlight:\n  enable: true\n  line_number: false\n  auto_detect: false\n  tab_replace: ''\n  wrap: true\n  hljs: true\nprismjs:\n  enable: false\n  preprocess: true\n  line_number: true\n  tab_replace: ''\n```\n\n当前主题是atmo-one-dark，定义在highlight.css中，可自行修改","tags":["Hexo"]}]